#
# Copyright (C) 2019-2020 Vdaas.org Vald team ( kpango, rinx, kmrmt )
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# @schema {"name": "defaults", "type": "object"}
# The values in the defaults section will be used for common settings in each component if not specified in its sections.
defaults:
  # @schema {"name": "defaults.time_zone", "type": "string"}
  # defaults.time_zone -- Time zone
  time_zone: UTC
  # @schema {"name": "defaults.logging", "type": "object", "anchor": "logging"}
  logging:
    # @schema {"name": "defaults.logging.logger", "type": "string", "enum": ["glg"]}
    # defaults.logging.logger -- logger name.
    # currently logger must be `glg`.
    logger: glg
    # @schema {"name": "defaults.logging.level", "type": "string", "enum": ["debug", "info", "warn", "error", "fatal"]}
    # defaults.logging.level -- logging level.
    # logging level must be `debug`, `info`, `warn`, `error` or `fatal`.
    level: debug
    # @schema {"name": "defaults.logging.format", "type": "string", "enum": ["raw", "json"]}
    # defaults.logging.format -- logging format.
    # logging format must be `raw` or `json`
    format: raw
  # @schema {"name": "defaults.image", "type": "object"}
  image:
    # @schema {"name": "defaults.image.tag", "type": "string"}
    # defaults.image.tag -- docker image tag
    tag: v0.0.49
  # @schema {"name": "defaults.server_config", "type": "object", "anchor": "server_config"}
  server_config:
    # @schema {"name": "defaults.server_config.servers", "type": "object"}
    servers:
      # @schema {"name": "defaults.server_config.servers.rest", "type": "object"}
      rest:
        # @schema {"name": "defaults.server_config.servers.rest.enabled", "type": "boolean"}
        # defaults.server_config.servers.rest.enabled -- REST server enabled
        enabled: false
        # @schema {"name": "defaults.server_config.servers.rest.host", "type": "string"}
        # defaults.server_config.servers.rest.host -- REST server host
        host: 0.0.0.0
        # @schema {"name": "defaults.server_config.servers.rest.port", "type": "integer", "minimum": 0, "maximum": 65535}
        # defaults.server_config.servers.rest.port -- REST server port
        port: 8080
        # @schema {"name": "defaults.server_config.servers.rest.servicePort", "type": "integer", "minimum": 0, "maximum": 65535}
        # defaults.server_config.servers.rest.servicePort -- REST server service port
        servicePort: 8080
        # @schema {"name": "defaults.server_config.servers.rest.server", "type": "object"}
        server:
          # @schema {"name": "defaults.server_config.servers.rest.server.mode", "type": "string"}
          # defaults.server_config.servers.rest.server.mode -- REST server server mode
          mode: REST
          # @schema {"name": "defaults.server_config.servers.rest.server.probe_wait_time", "type": "string"}
          # defaults.server_config.servers.rest.server.probe_wait_time -- REST server probe wait time
          probe_wait_time: 3s
          # @schema {"name": "defaults.server_config.servers.rest.server.http", "type": "object"}
          http:
            # @schema {"name": "defaults.server_config.servers.rest.server.shutdown_duration", "type": "string"}
            # defaults.server_config.servers.rest.server.http.shutdown_duration -- REST server shutdown duration
            shutdown_duration: 5s
            # @schema {"name": "defaults.server_config.servers.rest.server.handler_timeout", "type": "string"}
            # defaults.server_config.servers.rest.server.http.handler_timeout -- REST server handler timeout
            handler_timeout: 5s
            # @schema {"name": "defaults.server_config.servers.rest.server.idle_timeout", "type": "string"}
            # defaults.server_config.servers.rest.server.http.idle_timeout -- REST server idle timeout
            idle_timeout: 2s
            # @schema {"name": "defaults.server_config.servers.rest.server.read_header_timeout", "type": "string"}
            # defaults.server_config.servers.rest.server.http.read_header_timeout -- REST server read header timeout
            read_header_timeout: 1s
            # @schema {"name": "defaults.server_config.servers.rest.server.read_timeout", "type": "string"}
            # defaults.server_config.servers.rest.server.http.read_timeout -- REST server read timeout
            read_timeout: 1s
            # @schema {"name": "defaults.server_config.servers.rest.server.write_timeout", "type": "string"}
            # defaults.server_config.servers.rest.server.http.write_timeout -- REST server write timeout
            write_timeout: 1s
      # @schema {"name": "defaults.server_config.servers.grpc", "type": "object"}
      grpc:
        # @schema {"name": "defaults.server_config.servers.grpc.enabled", "type": "boolean"}
        # defaults.server_config.servers.grpc.enabled -- gRPC server enabled
        enabled: true
        # @schema {"name": "defaults.server_config.servers.grpc.host", "type": "string"}
        # defaults.server_config.servers.grpc.host -- gRPC server host
        host: 0.0.0.0
        # @schema {"name": "defaults.server_config.servers.grpc.port", "type": "integer", "minimum": 0, "maximum": 65535}
        # defaults.server_config.servers.grpc.port -- gRPC server port
        port: 8081
        # @schema {"name": "defaults.server_config.servers.grpc.servicePort", "type": "integer", "minimum": 0, "maximum": 65535}
        # defaults.server_config.servers.grpc.servicePort -- gRPC server service port
        servicePort: 8081
        # @schema {"name": "defaults.server_config.servers.grpc.server", "type": "object"}
        server:
          # @schema {"name": "defaults.server_config.servers.grpc.server.mode", "type": "string"}
          # defaults.server_config.servers.grpc.server.mode -- gRPC server server mode
          mode: GRPC
          # @schema {"name": "defaults.server_config.servers.grpc.server.probe_wait_time", "type": "string"}
          # defaults.server_config.servers.grpc.server.probe_wait_time -- gRPC server probe wait time
          probe_wait_time: "3s"
          # @schema {"name": "defaults.server_config.servers.grpc.server.grpc", "type": "object"}
          grpc:
            # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.bidirectional_stream_concurrency", "type": "integer"}
            # defaults.server_config.servers.grpc.server.grpc.bidirectional_stream_concurrency -- gRPC server bidirectional stream concurrency
            bidirectional_stream_concurrency: 20
            # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.max_receive_message_size", "type": "integer"}
            # defaults.server_config.servers.grpc.server.grpc.max_receive_message_size -- gRPC server max receive message size
            max_receive_message_size: 0
            # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.max_send_message_size", "type": "integer"}
            # defaults.server_config.servers.grpc.server.grpc.max_send_message_size -- gRPC server max send message size
            max_send_message_size: 0
            # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.initial_window_size", "type": "integer"}
            # defaults.server_config.servers.grpc.server.grpc.initial_window_size -- gRPC server initial window size
            initial_window_size: 0
            # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.initial_conn_window_size", "type": "integer"}
            # defaults.server_config.servers.grpc.server.grpc.initial_conn_window_size -- gRPC server initial connection window size
            initial_conn_window_size: 0
            # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.keepalive", "type": "object"}
            keepalive:
              # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.keepalive.max_conn_idle", "type": "string"}
              # defaults.server_config.servers.grpc.server.grpc.keepalive.max_conn_idle -- gRPC server keep alive max connection idle
              max_conn_idle: ""
              # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.keepalive.max_conn_age", "type": "string"}
              # defaults.server_config.servers.grpc.server.grpc.keepalive.max_conn_age -- gRPC server keep alive max connection age
              max_conn_age: ""
              # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.keepalive.max_conn_age_grace", "type": "string"}
              # defaults.server_config.servers.grpc.server.grpc.keepalive.max_conn_age_grace -- gRPC server keep alive max connection age grace
              max_conn_age_grace: ""
              # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.keepalive.time", "type": "string"}
              # defaults.server_config.servers.grpc.server.grpc.keepalive.time -- gRPC server keep alive time
              time: ""
              # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.keepalive.timeout", "type": "string"}
              # defaults.server_config.servers.grpc.server.grpc.keepalive.timeout -- gRPC server keep alive timeout
              timeout: ""
            # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.write_buffer_size", "type": "integer"}
            # defaults.server_config.servers.grpc.server.grpc.write_buffer_size -- gRPC server write buffer size
            write_buffer_size: 0
            # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.read_buffer_size", "type": "integer"}
            # defaults.server_config.servers.grpc.server.grpc.read_buffer_size -- gRPC server read buffer size
            read_buffer_size: 0
            # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.connection_timeout", "type": "string"}
            # defaults.server_config.servers.grpc.server.grpc.connection_timeout -- gRPC server connection timeout
            connection_timeout: ""
            # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.max_header_list_size", "type": "integer"}
            # defaults.server_config.servers.grpc.server.grpc.max_header_list_size -- gRPC server max header list size
            max_header_list_size: 0
            # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.header_table_size", "type": "integer"}
            # defaults.server_config.servers.grpc.server.grpc.header_table_size -- gRPC server header table size
            header_table_size: 0
            # @schema {"name": "defaults.server_config.servers.grpc.server.grpc.interceptors", "type": "array"}
            # defaults.server_config.servers.grpc.server.grpc.interceptors -- gRPC server interceptors
            interceptors: []
          # @schema {"name": "defaults.server_config.servers.grpc.server.restart", "type": "boolean"}
          # defaults.server_config.servers.grpc.server.restart -- gRPC server restart
          restart: true
    # @schema {"name": "defaults.server_config.healths", "type": "object"}
    healths:
      # @schema {"name": "defaults.server_config.healths.liveness", "type": "object"}
      liveness:
        # @schema {"name": "defaults.server_config.healths.liveness.enabled", "type": "boolean"}
        # defaults.server_config.healths.liveness.enabled -- liveness server enabled
        enabled: true
        # @schema {"name": "defaults.server_config.healths.liveness.host", "type": "string"}
        # defaults.server_config.healths.liveness.host -- liveness server host
        host: 0.0.0.0
        # @schema {"name": "defaults.server_config.healths.liveness.port", "type": "integer", "minimum": 0, "maximum": 65535}
        # defaults.server_config.healths.liveness.port -- liveness server port
        port: 3000
        # @schema {"name": "defaults.server_config.healths.liveness.servicePort", "type": "integer", "minimum": 0, "maximum": 65535}
        # defaults.server_config.healths.liveness.servicePort -- liveness server service port
        servicePort: 3000
        # @schema {"name": "defaults.server_config.healths.liveness.livenessProbe", "type": "object"}
        livenessProbe:
          # @schema {"name": "defaults.server_config.healths.liveness.livenessProbe.httpGet", "type": "object"}
          httpGet:
            # @schema {"name": "defaults.server_config.healths.liveness.livenessProbe.httpGet.path", "type": "string"}
            # defaults.server_config.healths.liveness.livenessProbe.httpGet.path -- liveness probe path
            path: /liveness
            # @schema {"name": "defaults.server_config.healths.liveness.livenessProbe.httpGet.port", "type": "string"}
            # defaults.server_config.healths.liveness.livenessProbe.httpGet.port -- liveness probe port
            port: liveness
            # @schema {"name": "defaults.server_config.healths.liveness.livenessProbe.httpGet.scheme", "type": "string"}
            # defaults.server_config.healths.liveness.livenessProbe.httpGet.scheme -- liveness probe scheme
            scheme: HTTP
          # @schema {"name": "defaults.server_config.healths.liveness.livenessProbe.initialDelaySeconds", "type": "integer"}
          # defaults.server_config.healths.liveness.livenessProbe.initialDelaySeconds -- liveness probe initial delay seconds
          initialDelaySeconds: 5
          # @schema {"name": "defaults.server_config.healths.liveness.livenessProbe.timetoutSeconds", "type": "integer"}
          # defaults.server_config.healths.liveness.livenessProbe.timeoutSeconds -- liveness probe timeout seconds
          timeoutSeconds: 2
          # @schema {"name": "defaults.server_config.healths.liveness.livenessProbe.successThreshold", "type": "integer"}
          # defaults.server_config.healths.liveness.livenessProbe.successThreshold -- liveness probe success threshold
          successThreshold: 1
          # @schema {"name": "defaults.server_config.healths.liveness.livenessProbe.failureThreshold", "type": "integer"}
          # defaults.server_config.healths.liveness.livenessProbe.failureThreshold -- liveness probe failure threshold
          failureThreshold: 2
          # @schema {"name": "defaults.server_config.healths.liveness.livenessProbe.periodSeconds", "type": "integer"}
          # defaults.server_config.healths.liveness.livenessProbe.periodSeconds -- liveness probe period seconds
          periodSeconds: 3
        # @schema {"name": "defaults.server_config.healths.liveness.server", "type": "object"}
        server:
          # @schema {"name": "defaults.server_config.healths.liveness.server.mode", "type": "string"}
          # defaults.server_config.healths.liveness.server.mode -- liveness server mode
          mode: ""
          # @schema {"name": "defaults.server_config.healths.liveness.server.probe_wait_time", "type": "string"}
          # defaults.server_config.healths.liveness.server.probe_wait_time -- liveness server probe wait time
          probe_wait_time: "3s"
          # @schema {"name": "defaults.server_config.healths.liveness.server.http", "type": "object"}
          http:
            # @schema {"name": "defaults.server_config.healths.liveness.server.http.shutdown_duration", "type": "string"}
            # defaults.server_config.healths.liveness.server.http.shutdown_duration -- liveness server shutdown duration
            shutdown_duration: "5s"
            # @schema {"name": "defaults.server_config.healths.liveness.server.http.handler_timeout", "type": "string"}
            # defaults.server_config.healths.liveness.server.http.handler_timeout -- liveness server handler timeout
            handler_timeout: ""
            # @schema {"name": "defaults.server_config.healths.liveness.server.http.idle_timeout", "type": "string"}
            # defaults.server_config.healths.liveness.server.http.idle_timeout -- liveness server idle timeout
            idle_timeout: ""
            # @schema {"name": "defaults.server_config.healths.liveness.server.http.read_header_timeout", "type": "string"}
            # defaults.server_config.healths.liveness.server.http.read_header_timeout -- liveness server read header timeout
            read_header_timeout: ""
            # @schema {"name": "defaults.server_config.healths.liveness.server.http.read_timeout", "type": "string"}
            # defaults.server_config.healths.liveness.server.http.read_timeout -- liveness server read timeout
            read_timeout: ""
            # @schema {"name": "defaults.server_config.healths.liveness.server.http.write_timeout", "type": "string"}
            # defaults.server_config.healths.liveness.server.http.write_timeout -- liveness server write timeout
            write_timeout: ""
      # @schema {"name": "defaults.server_config.healths.readiness", "type": "object"}
      readiness:
        # @schema {"name": "defaults.server_config.healths.readiness.enabled", "type": "boolean"}
        # defaults.server_config.healths.readiness.enabled -- readiness server enabled
        enabled: true
        # @schema {"name": "defaults.server_config.healths.readiness.host", "type": "string"}
        # defaults.server_config.healths.readiness.host -- readiness server host
        host: 0.0.0.0
        # @schema {"name": "defaults.server_config.healths.readiness.port", "type": "integer", "minimum": 0, "maximum": 65535}
        # defaults.server_config.healths.readiness.port -- readiness server port
        port: 3001
        # @schema {"name": "defaults.server_config.healths.readiness.servicePort", "type": "integer", "minimum": 0, "maximum": 65535}
        # defaults.server_config.healths.readiness.servicePort -- readiness server service port
        servicePort: 3001
        # @schema {"name": "defaults.server_config.healths.readiness.readinessProbe", "type": "object"}
        readinessProbe:
          # @schema {"name": "defaults.server_config.healths.readiness.readinessProbe.httpGet", "type": "object"}
          httpGet:
            # @schema {"name": "defaults.server_config.healths.readiness.readinessProbe.httpGet.path", "type": "string"}
            # defaults.server_config.healths.readiness.readinessProbe.httpGet.path -- readiness probe path
            path: /readiness
            # @schema {"name": "defaults.server_config.healths.readiness.readinessProbe.httpGet.port", "type": "string"}
            # defaults.server_config.healths.readiness.readinessProbe.httpGet.port -- readiness probe port
            port: readiness
            # @schema {"name": "defaults.server_config.healths.readiness.readinessProbe.httpGet.scheme", "type": "string"}
            # defaults.server_config.healths.readiness.readinessProbe.httpGet.scheme -- readiness probe scheme
            scheme: HTTP
          # @schema {"name": "defaults.server_config.healths.readiness.readinessProbe.initialDelaySeconds", "type": "integer"}
          # defaults.server_config.healths.readiness.readinessProbe.initialDelaySeconds -- readiness probe initial delay seconds
          initialDelaySeconds: 10
          # @schema {"name": "defaults.server_config.healths.readiness.readinessProbe.timeoutSeconds", "type": "integer"}
          # defaults.server_config.healths.readiness.readinessProbe.timeoutSeconds -- readiness probe timeout seconds
          timeoutSeconds: 2
          # @schema {"name": "defaults.server_config.healths.readiness.readinessProbe.successThreshold", "type": "integer"}
          # defaults.server_config.healths.readiness.readinessProbe.successThreshold -- readiness probe success threshold
          successThreshold: 1
          # @schema {"name": "defaults.server_config.healths.readiness.readinessProbe.failureThreshold", "type": "integer"}
          # defaults.server_config.healths.readiness.readinessProbe.failureThreshold -- readiness probe failure threshold
          failureThreshold: 2
          # @schema {"name": "defaults.server_config.healths.readiness.readinessProbe.periodSeconds", "type": "integer"}
          # defaults.server_config.healths.readiness.readinessProbe.periodSeconds -- readiness probe period seconds
          periodSeconds: 3
        # @schema {"name": "defaults.server_config.healths.readiness.server", "type": "object"}
        server:
          # @schema {"name": "defaults.server_config.healths.readiness.server.mode", "type": "string"}
          # defaults.server_config.healths.readiness.server.mode -- readiness server mode
          mode: ""
          # @schema {"name": "defaults.server_config.healths.readiness.server.probe_wait_time", "type": "string"}
          # defaults.server_config.healths.readiness.server.probe_wait_time -- readiness server probe wait time
          probe_wait_time: "3s"
          # @schema {"name": "defaults.server_config.healths.readiness.server.http", "type": "object"}
          http:
            # @schema {"name": "defaults.server_config.healths.readiness.server.http.shutdown_duration", "type": "string"}
            # defaults.server_config.healths.readiness.server.http.shutdown_duration -- readiness server shutdown duration
            shutdown_duration: "0s"
            # @schema {"name": "defaults.server_config.healths.readiness.server.http.handler_timeout", "type": "string"}
            # defaults.server_config.healths.readiness.server.http.handler_timeout -- readiness server handler timeout
            handler_timeout: ""
            # @schema {"name": "defaults.server_config.healths.readiness.server.http.idle_timeout", "type": "string"}
            # defaults.server_config.healths.readiness.server.http.idle_timeout -- readiness server idle timeout
            idle_timeout: ""
            # @schema {"name": "defaults.server_config.healths.readiness.server.http.read_header_timeout", "type": "string"}
            # defaults.server_config.healths.readiness.server.http.read_header_timeout -- readiness server read header timeout
            read_header_timeout: ""
            # @schema {"name": "defaults.server_config.healths.readiness.server.http.read_timeout", "type": "string"}
            # defaults.server_config.healths.readiness.server.http.read_timeout -- readiness server read timeout
            read_timeout: ""
            # @schema {"name": "defaults.server_config.healths.readiness.server.http.write_timeout", "type": "string"}
            # defaults.server_config.healths.readiness.server.http.write_timeout -- readiness server write timeout
            write_timeout: ""
    # @schema {"name": "defaults.server_config.metrics", "type": "object"}
    metrics:
      # @schema {"name": "defaults.server_config.metrics.pprof", "type": "object"}
      pprof:
        # @schema {"name": "defaults.server_config.metrics.pprof.enabled", "type": "boolean"}
        # defaults.server_config.metrics.pprof.enabled -- pprof server enabled
        enabled: false
        # @schema {"name": "defaults.server_config.metrics.pprof.host", "type": "string"}
        # defaults.server_config.metrics.pprof.host -- pprof server host
        host: 0.0.0.0
        # @schema {"name": "defaults.server_config.metrics.pprof.port", "type": "integer", "minimum": 0, "maximum": 65535}
        # defaults.server_config.metrics.pprof.port -- pprof server port
        port: 6060
        # @schema {"name": "defaults.server_config.metrics.pprof.servicePort", "type": "integer", "minimum": 0, "maximum": 65535}
        # defaults.server_config.metrics.pprof.servicePort -- pprof server service port
        servicePort: 6060
        # @schema {"name": "defaults.server_config.metrics.pprof.server", "type": "object"}
        server:
          # @schema {"name": "defaults.server_config.metrics.pprof.server.mode", "type": "string"}
          # defaults.server_config.metrics.pprof.server.mode -- pprof server mode
          mode: REST
          # @schema {"name": "defaults.server_config.metrics.pprof.server.probe_wait_time", "type": "string"}
          # defaults.server_config.metrics.pprof.server.probe_wait_time -- pprof server probe wait time
          probe_wait_time: 3s
          # @schema {"name": "defaults.server_config.metrics.pprof.server.http", "type": "object"}
          http:
            # @schema {"name": "defaults.server_config.metrics.pprof.server.http.shutdown_duration", "type": "string"}
            # defaults.server_config.metrics.pprof.server.http.shutdown_duration -- pprof server shutdown duration
            shutdown_duration: 5s
            # @schema {"name": "defaults.server_config.metrics.pprof.server.http.handler_timeout", "type": "string"}
            # defaults.server_config.metrics.pprof.server.http.handler_timeout -- pprof server handler timeout
            handler_timeout: 5s
            # @schema {"name": "defaults.server_config.metrics.pprof.server.http.idle_timeout", "type": "string"}
            # defaults.server_config.metrics.pprof.server.http.idle_timeout -- pprof server idle timeout
            idle_timeout: 2s
            # @schema {"name": "defaults.server_config.metrics.pprof.server.http.read_header_timeout", "type": "string"}
            # defaults.server_config.metrics.pprof.server.http.read_header_timeout -- pprof server read header timeout
            read_header_timeout: 1s
            # @schema {"name": "defaults.server_config.metrics.pprof.server.http.read_timeout", "type": "string"}
            # defaults.server_config.metrics.pprof.server.http.read_timeout -- pprof server read timeout
            read_timeout: 1s
            # @schema {"name": "defaults.server_config.metrics.pprof.server.http.write_timeout", "type": "string"}
            # defaults.server_config.metrics.pprof.server.http.write_timeout -- pprof server write timeout
            write_timeout: 1s
      # @schema {"name": "defaults.server_config.metrics.prometheus", "type": "object"}
      prometheus:
        # @schema {"name": "defaults.server_config.metrics.prometheus.enabled", "type": "boolean"}
        # defaults.server_config.metrics.prometheus.enabled -- prometheus server enabled
        enabled: false
        # @schema {"name": "defaults.server_config.metrics.prometheus.host", "type": "string"}
        # defaults.server_config.metrics.prometheus.host -- prometheus server host
        host: 0.0.0.0
        # @schema {"name": "defaults.server_config.metrics.prometheus.port", "type": "integer", "minimum": 0, "maximum": 65535}
        # defaults.server_config.metrics.prometheus.port -- prometheus server port
        port: 6061
        # @schema {"name": "defaults.server_config.metrics.prometheus.servicePort", "type": "integer", "minimum": 0, "maximum": 65535}
        # defaults.server_config.metrics.prometheus.servicePort -- prometheus server service port
        servicePort: 6061
        # @schema {"name": "defaults.server_config.metrics.prometheus.server", "type": "object"}
        server:
          # @schema {"name": "defaults.server_config.metrics.prometheus.server.mode", "type": "string"}
          # defaults.server_config.metrics.prometheus.server.mode -- prometheus server mode
          mode: REST
          # @schema {"name": "defaults.server_config.metrics.prometheus.server.probe_wait_time", "type": "string"}
          # defaults.server_config.metrics.prometheus.server.probe_wait_time -- prometheus server probe wait time
          probe_wait_time: 3s
          # @schema {"name": "defaults.server_config.metrics.prometheus.server.http", "type": "object"}
          http:
            # @schema {"name": "defaults.server_config.metrics.prometheus.server.http.shutdown_duration", "type": "string"}
            # defaults.server_config.metrics.prometheus.server.http.shutdown_duration -- prometheus server shutdown duration
            shutdown_duration: 5s
            # @schema {"name": "defaults.server_config.metrics.prometheus.server.http.handler_timeout", "type": "string"}
            # defaults.server_config.metrics.prometheus.server.http.handler_timeout -- prometheus server handler timeout
            handler_timeout: 5s
            # @schema {"name": "defaults.server_config.metrics.prometheus.server.http.idle_timeout", "type": "string"}
            # defaults.server_config.metrics.prometheus.server.http.idle_timeout -- prometheus server idle timeout
            idle_timeout: 2s
            # @schema {"name": "defaults.server_config.metrics.prometheus.server.http.read_header_timeout", "type": "string"}
            # defaults.server_config.metrics.prometheus.server.http.read_header_timeout -- prometheus server read header timeout
            read_header_timeout: 1s
            # @schema {"name": "defaults.server_config.metrics.prometheus.server.http.read_timeout", "type": "string"}
            # defaults.server_config.metrics.prometheus.server.http.read_timeout -- prometheus server read timeout
            read_timeout: 1s
            # @schema {"name": "defaults.server_config.metrics.prometheus.server.http.write_timeout", "type": "string"}
            # defaults.server_config.metrics.prometheus.server.http.write_timeout -- prometheus server write timeout
            write_timeout: 1s
    # @schema {"name": "defaults.server_config.full_shutdown_duration", "type": "string"}
    # defaults.server_config.full_shutdown_duration -- server full shutdown duration
    full_shutdown_duration: 600s
    # @schema {"name": "defaults.server_config.tls", "type": "object", "anchor": "tls"}
    tls:
      # @schema {"name": "defaults.server_config.tls.enabled", "type": "boolean"}
      # defaults.server_config.tls.enabled -- TLS enabled
      enabled: false
      # @schema {"name": "defaults.server_config.tls.cert", "type": "string"}
      # defaults.server_config.tls.cert -- TLS cert path
      cert: /path/to/cert
      # @schema {"name": "defaults.server_config.tls.key", "type": "string"}
      # defaults.server_config.tls.key -- TLS key path
      key: /path/to/key
      # @schema {"name": "defaults.server_config.tls.ca", "type": "string"}
      # defaults.server_config.tls.ca -- TLS ca path
      ca: /path/to/ca
  # @schema {"name": "defaults.grpc", "type": "object"}
  grpc:
    # @schema {"name": "defaults.grpc.client", "type": "object", "anchor": "grpc.client"}
    client:
      # @schema {"name": "defaults.grpc.client.addrs", "type": "array", "items": {"type": "string"}}
      # defaults.grpc.client.addrs -- gRPC client addresses
      addrs: []
      # @schema {"name": "defaults.grpc.client.health_check_duration", "type": "string"}
      # defaults.grpc.client.health_check_duration -- gRPC client health check duration
      health_check_duration: "1s"
      # @schema {"name": "defaults.grpc.client.connection_pool", "type": "object"}
      connection_pool:
        # @schema {"name": "defaults.grpc.client.connection_pool.enable_dns_resolver", "type": "boolean"}
        # defaults.grpc.client.connection_pool.enable_dns_resolver -- enables gRPC client connection pool dns resolver, when enabled vald uses ip handshake exclude dns discovery which improves network performance
        enable_dns_resolver: true
        # @schema {"name": "defaults.grpc.client.connection_pool.enable_rebalance", "type": "boolean"}
        # defaults.grpc.client.connection_pool.enable_rebalance -- enables gRPC client connection pool rebalance
        enable_rebalance: true
        # @schema {"name": "defaults.grpc.client.connection_pool.rebalance_duration", "type": "string"}
        # defaults.grpc.client.connection_pool.rebalance_duration -- gRPC client connection pool rebalance duration
        rebalance_duration: 30m
        # @schema {"name": "defaults.grpc.client.connection_pool.size", "type": "integer"}
        # defaults.grpc.client.connection_pool.size -- gRPC client connection pool size
        size: 3
        # @schema {"name": "defaults.grpc.client.connection_pool.old_conn_close_duration", "type": "string"}
        # defaults.grpc.client.connection_pool.old_conn_close_duration -- makes delay before gRPC client connection closing during connection pool rebalance
        old_conn_close_duration: "3s"
      # @schema {"name": "defaults.grpc.client.backoff", "type": "object", "anchor": "backoff"}
      backoff:
        # @schema {"name": "defaults.grpc.client.backoff.initial_duration", "type": "string"}
        # defaults.grpc.client.backoff.initial_duration -- gRPC client backoff initial duration
        initial_duration: 5ms
        # @schema {"name": "defaults.grpc.client.backoff.backoff_time_limit", "type": "string"}
        # defaults.grpc.client.backoff.backoff_time_limit -- gRPC client backoff time limit
        backoff_time_limit: 5s
        # @schema {"name": "defaults.grpc.client.backoff.maximum_duration", "type": "string"}
        # defaults.grpc.client.backoff.maximum_duration -- gRPC client backoff maximum duration
        maximum_duration: 5s
        # @schema {"name": "defaults.grpc.client.backoff.jitter_limit", "type": "string"}
        # defaults.grpc.client.backoff.jitter_limit -- gRPC client backoff jitter limit
        jitter_limit: 100ms
        # @schema {"name": "defaults.grpc.client.backoff.backoff_factor", "type": "number"}
        # defaults.grpc.client.backoff.backoff_factor -- gRPC client backoff factor
        backoff_factor: 1.1
        # @schema {"name": "defaults.grpc.client.backoff.retry_count", "type": "integer"}
        # defaults.grpc.client.backoff.retry_count -- gRPC client backoff retry count
        retry_count: 100
        # @schema {"name": "defaults.grpc.client.backoff.enable_error_log", "type": "boolean"}
        # defaults.grpc.client.backoff.enable_error_log -- gRPC client backoff log enabled
        enable_error_log: true
      # @schema {"name": "defaults.grpc.client.call_option", "type": "object"}
      call_option:
        # @schema {"name": "defaults.grpc.client.wait_for_ready", "type": "boolean"}
        # defaults.grpc.client.call_option.wait_for_ready -- gRPC client call option wait for ready
        wait_for_ready: true
        # @schema {"name": "defaults.grpc.client.max_retry_rpc_buffer_size", "type": "integer"}
        # defaults.grpc.client.call_option.max_retry_rpc_buffer_size -- gRPC client call option max retry rpc buffer size
        max_retry_rpc_buffer_size: 0
        # @schema {"name": "defaults.grpc.client.max_recv_msg_size", "type": "integer"}
        # defaults.grpc.client.call_option.max_recv_msg_size -- gRPC client call option max receive message size
        max_recv_msg_size: 0
        # @schema {"name": "defaults.grpc.client.max_send_msg_size", "type": "integer"}
        # defaults.grpc.client.call_option.max_send_msg_size -- gRPC client call option max send message size
        max_send_msg_size: 0
      # @schema {"name": "defaults.grpc.client.dial_option", "type": "object"}
      dial_option:
        # @schema {"name": "defaults.grpc.client.dial_option.write_buffer_size", "type": "integer"}
        # defaults.grpc.client.dial_option.write_buffer_size -- gRPC client dial option write buffer size
        write_buffer_size: 0
        # @schema {"name": "defaults.grpc.client.dial_option.read_buffer_size", "type": "integer"}
        # defaults.grpc.client.dial_option.read_buffer_size -- gRPC client dial option read buffer size
        read_buffer_size: 0
        # @schema {"name": "defaults.grpc.client.dial_option.initial_window_size", "type": "integer"}
        # defaults.grpc.client.dial_option.initial_window_size -- gRPC client dial option initial window size
        initial_window_size: 0
        # @schema {"name": "defaults.grpc.client.dial_option.initial_connection_window_size", "type": "integer"}
        # defaults.grpc.client.dial_option.initial_connection_window_size -- gRPC client dial option initial connection window size
        initial_connection_window_size: 0
        # @schema {"name": "defaults.grpc.client.dial_option.max_msg_size", "type": "integer"}
        # defaults.grpc.client.dial_option.max_msg_size -- gRPC client dial option max message size
        max_msg_size: 0
        # @schema {"name": "defaults.grpc.client.dial_option.max_backoff_delay", "type": "string"}
        # defaults.grpc.client.dial_option.max_backoff_delay -- gRPC client dial option max backoff delay
        max_backoff_delay: ""
        # @schema {"name": "defaults.grpc.client.dial_option.enable_backoff", "type": "boolean"}
        # defaults.grpc.client.dial_option.enable_backoff -- gRPC client dial option backoff enabled
        enable_backoff: false
        # @schema {"name": "defaults.grpc.client.dial_option.insecure", "type": "boolean"}
        # defaults.grpc.client.dial_option.insecure -- gRPC client dial option insecure enabled
        insecure: true
        # @schema {"name": "defaults.grpc.client.dial_option.timeout", "type": "string"}
        # defaults.grpc.client.dial_option.timeout -- gRPC client dial option timeout
        timeout: ""
        # @schema {"name": "defaults.grpc.client.dial_option.tcp", "type": "object", "anchor": "tcp"}
        tcp:
          # @schema {"name": "defaults.grpc.client.dial_option.tcp.dns", "type": "object"}
          dns:
            # @schema {"name": "defaults.grpc.client.dial_option.tcp.dns.cache_enabled", "type": "boolean"}
            # defaults.grpc.client.dial_option.tcp.dns.cache_enabled -- gRPC client TCP DNS cache enabled
            cache_enabled: true
            # @schema {"name": "defaults.grpc.client.dial_option.tcp.dns.refresh_duration", "type": "string"}
            # defaults.grpc.client.dial_option.tcp.dns.refresh_duration -- gRPC client TCP DNS cache refresh duration
            refresh_duration: 30m
            # @schema {"name": "defaults.grpc.client.dial_option.tcp.dns.cache_expiration", "type": "string"}
            # defaults.grpc.client.dial_option.tcp.dns.cache_expiration -- gRPC client TCP DNS cache expiration
            cache_expiration: 1h
          # @schema {"name": "defaults.grpc.client.dial_option.tcp.dialer", "type": "object"}
          dialer:
            # @schema {"name": "defaults.grpc.client.dial_option.tcp.dialer.timeout", "type": "string"}
            # defaults.grpc.client.dial_option.tcp.dialer.timeout -- gRPC client TCP dialer timeout
            timeout: ""
            # @schema {"name": "defaults.grpc.client.dial_option.tcp.dialer.keep_alive", "type": "string"}
            # defaults.grpc.client.dial_option.tcp.dialer.keep_alive -- gRPC client TCP dialer keep alive
            keep_alive: ""
            # @schema {"name": "defaults.grpc.client.dial_option.tcp.dialer.dual_stack_enabled", "type": "boolean"}
            # defaults.grpc.client.dial_option.tcp.dialer.dual_stack_enabled -- gRPC client TCP dialer dual stack enabled
            dual_stack_enabled: true
          # @schema {"name": "defaults.grpc.client.dial_option.tcp.tls", "alias": "tls"}
          tls:
            # defaults.grpc.client.dial_option.tcp.tls.enabled -- gRPC client TCP TLS enabled
            enabled: false
            # defaults.grpc.client.dial_option.tcp.tls.cert -- gRPC client TCP TLS cert path
            cert: /path/to/cert
            # defaults.grpc.client.dial_option.tcp.tls.key -- gRPC client TCP TLS key path
            key: /path/to/key
            # defaults.grpc.client.dial_option.tcp.tls.ca -- gRPC client TCP TLS ca path
            ca: /path/to/ca
        # @schema {"name": "defaults.grpc.client.dial_option.keep_alive", "type": "object"}
        keep_alive:
          # @schema {"name": "defaults.grpc.client.dial_option.keep_alive.time", "type": "string"}
          # defaults.grpc.client.dial_option.keep_alive.time -- gRPC client keep alive time
          time: ""
          # @schema {"name": "defaults.grpc.client.dial_option.keep_alive.timeout", "type": "string"}
          # defaults.grpc.client.dial_option.keep_alive.timeout -- gRPC client keep alive timeout
          timeout: ""
          # @schema {"name": "defaults.grpc.client.dial_option.keep_alive.permit_without_stream", "type": "boolean"}
          # defaults.grpc.client.dial_option.keep_alive.permit_without_stream -- gRPC client keep alive permit without stream
          permit_without_stream: false
      # @schema {"name": "defaults.grpc.client.tls", "alias": "tls"}
      tls:
        # defaults.grpc.client.tls.enabled -- gRPC client TLS enabled
        enabled: false
        # defaults.grpc.client.tls.cert -- gRPC client TLS cert path
        cert: /path/to/cert
        # defaults.grpc.client.tls.key -- gRPC client TLS key path
        key: /path/to/key
        # defaults.grpc.client.tls.ca -- gRPC client TLS ca path
        ca: /path/to/ca
  # @schema {"name": "defaults.observability", "type": "object", "anchor": "observability"}
  observability:
    # @schema {"name": "defaults.observability.enabled", "type": "boolean"}
    # defaults.observability.enabled -- observability features enabled
    enabled: false
    # @schema {"name": "defaults.observability.collector", "type": "object"}
    collector:
      # @schema {"name": "defaults.observability.collector.duration", "type": "string"}
      # defaults.observability.collector.duration -- metrics collect duration.
      # if it is set as 5s, enabled metrics are collected every 5 seconds.
      duration: 5s
      # @schema {"name": "defaults.observability.collector.metrics", "type": "object"}
      metrics:
        # @schema {"name": "defaults.observability.collector.metrics.enable_version_info", "type": "boolean"}
        # defaults.observability.collector.metrics.enable_version_info -- version info metrics enabled
        enable_version_info: true
        # @schema {"name": "defaults.observability.collector.metrics.version_info_labels", "type": "array", "items": {"type": "string", "enum": ["vald_version", "server_name", "git_commit", "build_time", "go_version", "go_os", "go_arch", "cgo_enabled", "ngt_version", "build_cpu_info_flags"]}}
        # defaults.observability.collector.metrics.version_info_labels -- enabled label names of version info
        version_info_labels:
          - "vald_version"
          - "server_name"
          - "git_commit"
          - "build_time"
          - "go_version"
          - "go_os"
          - "go_arch"
          - "ngt_version"
        # @schema {"name": "defaults.observability.collector.metrics.enable_memory", "type": "boolean"}
        # defaults.observability.collector.metrics.enable_memory -- memory metrics enabled
        enable_memory: true
        # @schema {"name": "defaults.observability.collector.metrics.enable_goroutine", "type": "boolean"}
        # defaults.observability.collector.metrics.enable_goroutine -- goroutine metrics enabled
        enable_goroutine: true
        # @schema {"name": "defaults.observability.collector.metrics.enable_cgo", "type": "boolean"}
        # defaults.observability.collector.metrics.enable_cgo -- CGO metrics enabled
        enable_cgo: true
    # @schema {"name": "defaults.observability.trace", "type": "object"}
    trace:
      # @schema {"name": "defaults.observability.trace.enabled", "type": "boolean"}
      # defaults.observability.trace.enabled -- trace enabled
      enabled: false
      # @schema {"name": "defaults.observability.trace.sampling_rate", "type": "number"}
      # defaults.observability.trace.sampling_rate -- trace sampling rate.
      # must be between 0.0 to 1.0.
      sampling_rate: 1.0
    # @schema {"name": "defaults.observability.prometheus", "type": "object"}
    prometheus:
      # @schema {"name": "defaults.observability.prometheus.enabled", "type": "boolean"}
      # defaults.observability.prometheus.enabled -- Prometheus exporter enabled
      enabled: false
      # @schema {"name": "defaults.observability.prometheus.endpoint", "type": "string"}
      # defaults.observability.prometheus.endpoint -- Prometheus exporter endpoint
      endpoint: /metrics
      # @schema {"name": "defaults.observability.prometheus.namespace", "type": "string"}
      # defaults.observability.prometheus.namespace -- prefix of exported metrics name
      namespace: vald
    # @schema {"name": "defaults.observability.jaeger", "type": "object"}
    jaeger:
      # @schema {"name": "defaults.observability.jaeger.enabled", "type": "boolean"}
      # defaults.observability.jaeger.enabled -- Jaeger exporter enabled
      enabled: false
      # @schema {"name": "defaults.observability.jaeger.collector_endpoint", "type": "string"}
      # defaults.observability.jaeger.collector_endpoint -- Jaeger collector endpoint
      collector_endpoint: "" # http://jaeger-collector.default.svc.cluster.local:14268/api/traces
      # @schema {"name": "defaults.observability.jaeger.agent_endpoint", "type": "string"}
      # defaults.observability.jaeger.agent_endpoint -- Jaeger agent endpoint
      agent_endpoint: jaeger-agent.default.svc.cluster.local:6831
      # @schema {"name": "defaults.observability.jaeger.username", "type": "string"}
      # defaults.observability.jaeger.username -- Jaeger username
      username: ""
      # @schema {"name": "defaults.observability.jaeger.password", "type": "string"}
      # defaults.observability.jaeger.password -- Jaeger password
      password: ""
      # @schema {"name": "defaults.observability.jaeger.service_name", "type": "string"}
      # defaults.observability.jaeger.service_name -- Jaeger service name
      service_name: vald
      # @schema {"name": "defaults.observability.jaeger.buffer_max_count", "type": "integer"}
      # defaults.observability.jaeger.buffer_max_count -- Jaeger buffer max count
      buffer_max_count: 10
    # @schema {"name": "defaults.observability.stackdriver", "type": "object"}
    stackdriver:
      # @schema {"name": "defaults.observability.stackdriver.project_id", "type": "string"}
      # defaults.observability.stackdriver.project_id -- project id for uploading the stats data
      project_id: ""
      # @schema {"name": "defaults.observability.stackdriver.client", "type": "object"}
      client:
        # @schema {"name": "defaults.observability.stackdriver.client.api_key", "type": "string"}
        # defaults.observability.stackdriver.client.api_key -- API key to be used as the basis for authentication.
        api_key: ""
        # @schema {"name": "defaults.observability.stackdriver.client.audiences", "type": "array", "items": {"type": "string"}}
        # defaults.observability.stackdriver.client.audiences -- to be used as the audience field ("aud") for the JWT token authentication.
        audiences: []
        # @schema {"name": "defaults.observability.stackdriver.client.credentials_file", "type": "string"}
        # defaults.observability.stackdriver.client.credentials_file -- service account or refresh token JSON credentials file.
        credentials_file: ""
        # @schema {"name": "defaults.observability.stackdriver.client.credentials_json", "type": "string"}
        # defaults.observability.stackdriver.client.credentials_json -- service account or refresh token JSON credentials.
        credentials_json: ""
        # @schema {"name": "defaults.observability.stackdriver.client.endpoint", "type": "string"}
        # defaults.observability.stackdriver.client.endpoint -- overrides the default endpoint to be used for a service.
        endpoint: ""
        # @schema {"name": "defaults.observability.stackdriver.client.quota_project", "type": "string"}
        # defaults.observability.stackdriver.client.quota_project -- the project used for quota and billing purposes.
        quota_project: ""
        # @schema {"name": "defaults.observability.stackdriver.client.request_reason", "type": "string"}
        # defaults.observability.stackdriver.client.request_reason -- a reason for making the request, which is intended to be recorded in audit logging.
        request_reason: ""
        # @schema {"name": "defaults.observability.stackdriver.client.scopes", "type": "array", "items": {"type": "string"}}
        # defaults.observability.stackdriver.client.scopes -- overrides the default OAuth2 scopes to be used for a service.
        scopes: []
        # @schema {"name": "defaults.observability.stackdriver.client.user_agent", "type": "string"}
        # defaults.observability.stackdriver.client.user_agent -- sets the User-Agent.
        user_agent: ""
        # @schema {"name": "defaults.observability.stackdriver.client.telemetry_enabled", "type": "boolean"}
        # defaults.observability.stackdriver.client.telemetry_enabled -- enables default telemetry settings on gRPC and HTTP clients.
        telemetry_enabled: true
        # @schema {"name": "defaults.observability.stackdriver.client.authentication_enabled", "type": "boolean"}
        # defaults.observability.stackdriver.client.authentication_enabled -- enables authentication.
        authentication_enabled: true
      # @schema {"name": "defaults.observability.stackdriver.exporter", "type": "object"}
      exporter:
        # @schema {"name": "defaults.observability.stackdriver.exporter.monitoring_enabled", "type": "boolean"}
        # defaults.observability.stackdriver.exporter.monitoring_enabled -- stackdriver monitoring enabled
        monitoring_enabled: false
        # @schema {"name": "defaults.observability.stackdriver.exporter.tracing_enabled", "type": "boolean"}
        # defaults.observability.stackdriver.exporter.tracing_enabled -- stackdriver tracing enabled
        tracing_enabled: false
        # @schema {"name": "defaults.observability.stackdriver.exporter.location", "type": "string"}
        # defaults.observability.stackdriver.exporter.location -- identifier of the GCP or AWS cloud region/zone the data is stored.
        location: ""
        # @schema {"name": "defaults.observability.stackdriver.exporter.bundle_delay_threshold", "type": "string"}
        # defaults.observability.stackdriver.exporter.bundle_delay_threshold -- the max amount of time the exporter can wait before uploading data.
        bundle_delay_threshold: "0"
        # @schema {"name": "defaults.observability.stackdriver.exporter.bundle_count_threshold", "type": "integer"}
        # defaults.observability.stackdriver.exporter.bundle_count_threshold -- how many view data events or trace spans can be buffered.
        bundle_count_threshold: 0
        # @schema {"name": "defaults.observability.stackdriver.exporter.trace_spans_buffer_max_bytes", "type": "integer"}
        # defaults.observability.stackdriver.exporter.trace_spans_buffer_max_bytes -- maximum size of spans that will be buffered.
        trace_spans_buffer_max_bytes: 0
        # @schema {"name": "defaults.observability.stackdriver.exporter.metric_prefix", "type": "string"}
        # defaults.observability.stackdriver.exporter.metric_prefix -- the prefix of a stackdriver metric names.
        metric_prefix: "vald.vdaas.org"
        # @schema {"name": "defaults.observability.stackdriver.exporter.skip_cmd", "type": "boolean"}
        # defaults.observability.stackdriver.exporter.skip_cmd -- skip all the CreateMetricDescriptor calls
        skip_cmd: false
        # @schema {"name": "defaults.observability.stackdriver.exporter.timeout", "type": "string"}
        # defaults.observability.stackdriver.exporter.timeout -- timeout for all API calls
        timeout: "5s"
        # @schema {"name": "defaults.observability.stackdriver.exporter.reporting_interval", "type": "string"}
        # defaults.observability.stackdriver.exporter.reporting_interval -- interval between reporting metrics
        reporting_interval: "1m"
        # @schema {"name": "defaults.observability.stackdriver.exporter.number_of_workers", "type": "integer"}
        # defaults.observability.stackdriver.exporter.number_of_workers -- number of workers
        number_of_workers: 1
      # @schema {"name": "defaults.observability.stackdriver.profiler", "type": "object"}
      profiler:
        # @schema {"name": "defaults.observability.stackdriver.profiler.enabled", "type": "boolean"}
        # defaults.observability.stackdriver.profiler.enabled -- stackdriver profiler enabled.
        enabled: false
        # @schema {"name": "defaults.observability.stackdriver.profiler.service", "type": "string"}
        # defaults.observability.stackdriver.profiler.service -- the name of the service.
        service: ""
        # @schema {"name": "defaults.observability.stackdriver.profiler.service_version", "type": "string"}
        # defaults.observability.stackdriver.profiler.service_version -- the version of the service.
        service_version: ""
        # @schema {"name": "defaults.observability.stackdriver.profiler.debug_logging", "type": "boolean"}
        # defaults.observability.stackdriver.profiler.debug_logging -- enables detailed logging from profiler.
        debug_logging: false
        # @schema {"name": "defaults.observability.stackdriver.profiler.mutex_profiling", "type": "boolean"}
        # defaults.observability.stackdriver.profiler.mutex_profiling -- enables mutex profiling.
        mutex_profiling: true
        # @schema {"name": "defaults.observability.stackdriver.profiler.cpu_profiling", "type": "boolean"}
        # defaults.observability.stackdriver.profiler.cpu_profiling -- enables CPU profiling.
        cpu_profiling: true
        # @schema {"name": "defaults.observability.stackdriver.profiler.alloc_profiling", "type": "boolean"}
        # defaults.observability.stackdriver.profiler.alloc_profiling -- enables allocation profiling.
        alloc_profiling: true
        # @schema {"name": "defaults.observability.stackdriver.profiler.heap_profiling", "type": "boolean"}
        # defaults.observability.stackdriver.profiler.heap_profiling -- enables heap profiling.
        heap_profiling: true
        # @schema {"name": "defaults.observability.stackdriver.profiler.goroutine_profiling", "type": "boolean"}
        # defaults.observability.stackdriver.profiler.goroutine_profiling -- enables goroutine profiling.
        goroutine_profiling: true
        # @schema {"name": "defaults.observability.stackdriver.profiler.alloc_force_gc", "type": "boolean"}
        # defaults.observability.stackdriver.profiler.alloc_force_gc -- forces GC before the collection of each heap profile.
        alloc_force_gc: false
        # @schema {"name": "defaults.observability.stackdriver.profiler.api_addr", "type": "string"}
        # defaults.observability.stackdriver.profiler.api_addr -- HTTP endpoint to use to connect to the profiler agent API.
        api_addr: ""
        # @schema {"name": "defaults.observability.stackdriver.profiler.instance", "type": "string"}
        # defaults.observability.stackdriver.profiler.instance -- the name of Compute Engine instance.
        # This is normally determined from the Compute Engine metadata server and doesn't need to be initialized.
        instance: ""
        # @schema {"name": "defaults.observability.stackdriver.profiler.zone", "type": "string"}
        # defaults.observability.stackdriver.profiler.zone -- the zone of Compute Engine instance.
        # This is normally determined from the Compute Engine metadata server and doesn't need to be initialized.
        zone: ""

# @schema {"name": "gateway", "type": "object"}
gateway:
  # @schema {"name": "gateway.vald", "type": "object"}
  vald:
    # @schema {"name": "gateway.vald.enabled", "type": "boolean"}
    # gateway.vald.enabled -- gateway enabled
    enabled: true
    # @schema {"name": "gateway.vald.version", "type": "string", "pattern": "^v[0-9]+\\.[0-9]+\\.[0-9]$", "anchor": "version"}
    # gateway.vald.version -- version of gateway config
    version: v0.0.0
    # @schema {"name": "gateway.vald.time_zone", "type": "string"}
    # gateway.vald.time_zone -- Time zone
    time_zone: ""
    # @schema {"name": "gateway.vald.logging", "alias": "logging"}
    # gateway.vald.logging -- logging config (overrides defaults.logging)
    logging: {}
    # @schema {"name": "gateway.vald.name", "type": "string"}
    # gateway.vald.name -- name of gateway deployment
    name: vald-gateway
    # @schema {"name": "gateway.vald.kind", "type": "string", "enum": ["Deployment", "DaemonSet"]}
    # gateway.vald.kind -- deployment kind: Deployment or DaemonSet
    kind: Deployment
    # @schema {"name": "gateway.vald.serviceType", "type": "string", "enum": ["ClusterIP", "LoadBalancer", "NodePort"]}
    # gateway.vald.serviceType -- service type: ClusterIP, LoadBalancer or NodePort
    serviceType: ClusterIP
    # @schema {"name": "gateway.vald.externalTrafficPolicy", "type": "string"}
    # gateway.vald.externalTrafficPolicy -- external traffic policy (can be specified when service type is LoadBalancer or NodePort) : Cluster or Local
    externalTrafficPolicy: ""
    # @schema {"name": "gateway.vald.progressDeadlineSeconds", "type": "integer"}
    # gateway.vald.progressDeadlineSeconds -- progress deadline seconds
    progressDeadlineSeconds: 600
    # @schema {"name": "gateway.vald.minReplicas", "type": "integer", "minimum": 0}
    # gateway.vald.minReplicas -- minimum number of replicas.
    # if HPA is disabled, the replicas will be set to this value
    minReplicas: 3
    # @schema {"name": "gateway.vald.maxReplicas", "type": "integer", "minimum": 0}
    # gateway.vald.maxReplicas -- maximum number of replicas.
    # if HPA is disabled, this value will be ignored.
    maxReplicas: 9
    # @schema {"name": "gateway.vald.maxUnavailable", "type": "string"}
    # gateway.vald.maxUnavailable -- maximum number of unavailable replicas
    maxUnavailable: 50%
    # @schema {"name": "gateway.vald.revisionHistoryLimit", "type": "integer", "minimum": 0}
    # gateway.vald.revisionHistoryLimit -- number of old history to retain to allow rollback
    revisionHistoryLimit: 2
    # @schema {"name": "gateway.vald.terminationGracePeriodSeconds", "type": "integer", "minimum": 0}
    # gateway.vald.terminationGracePeriodSeconds -- duration in seconds pod needs to terminate gracefully
    terminationGracePeriodSeconds: 30
    # @schema {"name": "gateway.vald.podPriority", "type": "object", "anchor": "podPriority"}
    podPriority:
      # @schema {"name": "gateway.vald.podPriority.enabled", "type": "boolean"}
      # gateway.vald.podPriority.enabled -- gateway pod PriorityClass enabled
      enabled: true
      # @schema {"name": "gateway.vald.podPriority.value", "type": "integer"}
      # gateway.vald.podPriority.value -- gateway pod PriorityClass value
      value: 1000000
    # @schema {"name": "gateway.vald.annotations", "type": "object"}
    # gateway.vald.annotations -- deployment annotations
    annotations: {}
    # @schema {"name": "gateway.vald.podAnnotations", "type": "object"}
    # gateway.vald.podAnnotations -- pod annotations
    podAnnotations: {}
    # @schema {"name": "gateway.vald.service", "type": "object", "anchor": "service"}
    service:
      # @schema {"name": "gateway.vald.service.annotations", "type": "object"}
      # gateway.vald.service.annotations -- service annotations
      annotations: {}
      # @schema {"name": "gateway.vald.service.labels", "type": "object"}
      # gateway.vald.service.labels -- service labels
      labels: {}
    # @schema {"name": "gateway.vald.hpa", "type": "object", "anchor": "hpa"}
    hpa:
      # @schema {"name": "gateway.vald.hpa.enabled", "type": "boolean"}
      # gateway.vald.hpa.enabled -- HPA enabled
      enabled: true
      # @schema {"name": "gateway.vald.hpa.targetCPUUtilizationPercentage", "type": "integer"}
      # gateway.vald.hpa.targetCPUUtilizationPercentage -- HPA CPU utilization percentage
      targetCPUUtilizationPercentage: 80
    # @schema {"name": "gateway.vald.image", "type": "object", "anchor": "image"}
    image:
      # @schema {"name": "gateway.vald.image.repository", "type": "string"}
      # gateway.vald.image.repository -- image repository
      repository: vdaas/vald-gateway
      # @schema {"name": "gateway.vald.image.tag", "type": "string"}
      # gateway.vald.image.tag -- image tag (overrides defaults.image.tag)
      tag: ""
      # @schema {"name": "gateway.vald.image.pullPolicy", "type": "string", "enum": ["Always", "Never", "IfNotPresent"]}
      # gateway.vald.image.pullPolicy -- image pull policy
      pullPolicy: Always
    # @schema {"name": "gateway.vald.rollingUpdate", "type": "object", "anchor": "rollingUpdate"}
    rollingUpdate:
      # @schema {"name": "gateway.vald.rollingUpdate.maxSurge", "type": "string"}
      # gateway.vald.rollingUpdate.maxSurge -- max surge of rolling update
      maxSurge: 25%
      # @schema {"name": "gateway.vald.rollingUpdate.maxUnavailable", "type": "string"}
      # gateway.vald.rollingUpdate.maxUnavailable -- max unavailable of rolling update
      maxUnavailable: 25%
    # @schema {"name": "gateway.vald.initContainers", "type": "array", "items": {"type": "object"}, "anchor": "initContainers"}
    # gateway.vald.initContainers -- init containers
    initContainers:
      - type: wait-for
        name: wait-for-manager-compressor
        target: compressor
        image: busybox
        sleepDuration: 2
      - type: wait-for
        name: wait-for-meta
        target: meta
        image: busybox
        sleepDuration: 2
      - type: wait-for
        name: wait-for-discoverer
        target: discoverer
        image: busybox
        sleepDuration: 2
      - type: wait-for
        name: wait-for-agent
        target: agent
        image: busybox
        sleepDuration: 2
    # @schema {"name": "gateway.vald.env", "type": "array", "items": {"type": "object"}, "anchor": "env"}
    # gateway.vald.env -- environment variables
    env:
      # - name: MY_NODE_NAME
      #   valueFrom:
      #     fieldRef:
      #       fieldPath: spec.nodeName
      - name: MY_POD_NAMESPACE
        valueFrom:
          fieldRef:
            fieldPath: metadata.namespace
    # @schema {"name": "gateway.vald.volumeMounts", "type": "array", "items": {"type": "object"}, "anchor": "volumeMounts"}
    # gateway.vald.volumeMounts -- volume mounts
    volumeMounts: []
    # @schema {"name": "gateway.vald.volumes", "type": "array", "items": {"type": "object"}, "anchor": "volumes"}
    # gateway.vald.volumes -- volumes
    volumes: []
    # @schema {"name": "gateway.vald.nodeName", "type": "string"}
    # gateway.vald.nodeName -- node name
    nodeName: ""
    # @schema {"name": "gateway.vald.nodeSelector", "type": "object", "anchor": "nodeSelector"}
    # gateway.vald.nodeSelector -- node selector
    nodeSelector: {}
    # @schema {"name": "gateway.vald.tolerations", "type": "array", "items": {"type": "object"}, "anchor": "tolerations"}
    # gateway.vald.tolerations -- tolerations
    tolerations: []
    # @schema {"name": "gateway.vald.affinity", "type": "object", "anchor": "affinity"}
    affinity:
      # @schema {"name": "gateway.vald.affinity.nodeAffinity", "type": "object"}
      nodeAffinity:
        # @schema {"name": "gateway.vald.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.vald.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution -- node affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # @schema {"name": "gateway.vald.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "object"}
        requiredDuringSchedulingIgnoredDuringExecution:
          # @schema {"name": "gateway.vald.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms", "type": "array", "items": {"type": "object"}}
          # gateway.vald.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms -- node affinity required node selectors
          nodeSelectorTerms: []
      # @schema {"name": "gateway.vald.affinity.podAffinity", "type": "object"}
      podAffinity:
        # @schema {"name": "gateway.vald.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.vald.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # @schema {"name": "gateway.vald.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.vald.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
      # @schema {"name": "gateway.vald.affinity.podAntiAffinity", "type": "object"}
      podAntiAffinity:
        # @schema {"name": "gateway.vald.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.vald.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              topologyKey: kubernetes.io/hostname
              labelSelector:
                matchExpressions:
                  - key: app
                    operator: In
                    values:
                      - vald-gateway
        # @schema {"name": "gateway.vald.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.vald.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
    # @schema {"name": "gateway.vald.topologySpreadConstraints", "type": "array", "items": {"type": "object"}, "anchor": "topologySpreadConstraints"}
    # gateway.vald.topologySpreadConstraints -- topology spread constraints of gateway pods
    topologySpreadConstraints: []
    # @schema {"name": "gateway.vald.server_config", "alias": "server_config"}
    # gateway.vald.server_config -- server config (overrides defaults.server_config)
    server_config:
      servers:
        rest: {}
        grpc: {}
      healths:
        liveness: {}
        readiness: {}
      metrics:
        pprof: {}
        prometheus: {}
    # @schema {"name": "gateway.vald.observability", "alias": "observability"}
    # gateway.vald.observability -- observability config (overrides defaults.observability)
    observability:
      jaeger:
        service_name: vald-gateway
      stackdriver:
        profiler:
          service: vald-gateway
    # @schema {"name": "gateway.vald.ingress", "type": "object"}
    ingress:
      # @schema {"name": "gateway.vald.ingress.enabled", "type": "boolean"}
      # gateway.vald.ingress.enabled -- gateway ingress enabled
      enabled: true
      # @schema {"name": "gateway.vald.ingress.annotations", "type": "object"}
      # gateway.vald.ingress.annotations -- annotations for ingress
      annotations:
        nginx.ingress.kubernetes.io/grpc-backend: "true"
      # @schema {"name": "gateway.vald.ingress.host", "type": "string"}
      # gateway.vald.ingress.host -- ingress hostname
      host: vald.gateway.vald.vdaas.org
      # @schema {"name": "gateway.vald.ingress.servicePort", "type": "string"}
      # gateway.vald.ingress.servicePort -- service port to be exposed by ingress
      servicePort: grpc
    # @schema {"name": "gateway.vald.resources", "type": "object", "anchor": "resources"}
    # gateway.vald.resources -- compute resources
    resources:
      # @schema {"name": "gateway.vald.resources.requests", "type": "object"}
      requests:
        cpu: 200m
        memory: 150Mi
      # @schema {"name": "gateway.vald.resources.limits", "type": "object"}
      limits:
        cpu: 2000m
        memory: 700Mi
    # @schema {"name": "gateway.vald.gateway_config", "type": "object"}
    gateway_config:
      # @schema {"name": "gateway.vald.gateway_config.agent_namespace", "type": "string"}
      # gateway.vald.gateway_config.agent_namespace -- agent namespace
      agent_namespace: _MY_POD_NAMESPACE_
      # @schema {"name": "gateway.vald.gateway_config.node_namespace", "type": "string"}
      # gateway.vald.gateway_config.node_name -- node name
      node_name: "" # _MY_NODE_NAME_
      # @schema {"name": "gateway.vald.gateway_config.index_replica", "type": "integer", "minimum": 1}
      # gateway.vald.gateway_config.index_replica -- number of index replica
      index_replica: 5
      # @schema {"name": "gateway.vald.gateway_config.discoverer", "type": "object"}
      discoverer:
        # @schema {"name": "gateway.vald.gateway_config.discoverer.duration", "type": "string"}
        # gateway.vald.gateway_config.discoverer.duration -- discoverer duration
        duration: 200ms
        # @schema {"name": "gateway.vald.gateway_config.discoverer.discover_client", "alias": "grpc.client"}
        # gateway.vald.gateway_config.discoverer.discover_client -- gRPC client for discoverer (overrides defaults.grpc.client)
        discover_client: {}
        # @schema {"name": "gateway.vald.gateway_config.discoverer.agent_client", "alias": "grpc.client"}
        # gateway.vald.gateway_config.discoverer.agent_client -- gRPC client for agents (overrides defaults.grpc.client)
        agent_client: {}
      # @schema {"name": "gateway.vald.gateway_config.meta", "type": "object"}
      meta:
        # @schema {"name": "gateway.vald.gateway_config.meta.client", "alias": "grpc.client"}
        # gateway.vald.gateway_config.meta.client -- gRPC client for meta (overrides defaults.grpc.client)
        client: {}
        # @schema {"name": "gateway.vald.gateway_config.meta.enable_cache", "type": "boolean"}
        # gateway.vald.gateway_config.meta.enable_cache -- meta cache enabled
        enable_cache: true
        # @schema {"name": "gateway.vald.gateway_config.meta.cache_expiration", "type": "string"}
        # gateway.vald.gateway_config.meta.cache_expiration -- meta cache expire duration
        cache_expiration: "30m"
        # @schema {"name": "gateway.vald.gateway_config.meta.expired_cache_check_duration", "type": "string"}
        # gateway.vald.gateway_config.meta.expired_cache_check_duration -- meta cache expired check duration
        expired_cache_check_duration: "3m"
      # @schema {"name": "gateway.vald.gateway_config.backup", "type": "object"}
      backup:
        # @schema {"name": "gateway.vald.gateway_config.backup.client", "alias": "grpc.client"}
        # gateway.vald.gateway_config.backup.client -- gRPC client for backup (overrides defaults.grpc.client)
        client: {}
  # @schema {"name": "gateway.backup", "type": "object"}
  backup:
    # @schema {"name": "gateway.backup.enabled", "type": "boolean"}
    # gateway.backup.enabled -- gateway enabled
    enabled: false
    # @schema {"name": "gateway.backup.version", "type": "string", "pattern": "^v[0-9]+\\.[0-9]+\\.[0-9]$", "anchor": "version"}
    # gateway.backup.version -- version of gateway config
    version: v0.0.0
    # @schema {"name": "gateway.backup.time_zone", "type": "string"}
    # gateway.backup.time_zone -- Time zone
    time_zone: ""
    # @schema {"name": "gateway.backup.logging", "alias": "logging"}
    # gateway.backup.logging -- logging config (overrides defaults.logging)
    logging: {}
    # @schema {"name": "gateway.backup.name", "type": "string"}
    # gateway.backup.name -- name of backup gateway deployment
    name: vald-gateway-backup
    # @schema {"name": "gateway.backup.kind", "type": "string", "enum": ["Deployment", "DaemonSet"]}
    # gateway.backup.kind -- deployment kind: Deployment or DaemonSet
    kind: Deployment
    # @schema {"name": "gateway.backup.serviceType", "type": "string", "enum": ["ClusterIP", "LoadBalancer", "NodePort"]}
    # gateway.backup.serviceType -- service type: ClusterIP, LoadBalancer or NodePort
    serviceType: ClusterIP
    # @schema {"name": "gateway.backup.externalTrafficPolicy", "type": "string"}
    # gateway.backup.externalTrafficPolicy -- external traffic policy (can be specified when service type is LoadBalancer or NodePort) : Cluster or Local
    externalTrafficPolicy: ""
    # @schema {"name": "gateway.backup.progressDeadlineSeconds", "type": "integer"}
    # gateway.backup.progressDeadlineSeconds -- progress deadline seconds
    progressDeadlineSeconds: 600
    # @schema {"name": "gateway.backup.minReplicas", "type": "integer", "minimum": 0}
    # gateway.backup.minReplicas -- minimum number of replicas.
    # if HPA is disabled, the replicas will be set to this value
    minReplicas: 3
    # @schema {"name": "gateway.backup.maxReplicas", "type": "integer", "minimum": 0}
    # gateway.backup.maxReplicas -- maximum number of replicas.
    # if HPA is disabled, this value will be ignored.
    maxReplicas: 9
    # @schema {"name": "gateway.backup.maxUnavailable", "type": "string"}
    # gateway.backup.maxUnavailable -- maximum number of unavailable replicas
    maxUnavailable: 50%
    # @schema {"name": "gateway.backup.revisionHistoryLimit", "type": "integer", "minimum": 0}
    # gateway.backup.revisionHistoryLimit -- number of old history to retain to allow rollback
    revisionHistoryLimit: 2
    # @schema {"name": "gateway.backup.terminationGracePeriodSeconds", "type": "integer", "minimum": 0}
    # gateway.backup.terminationGracePeriodSeconds -- duration in seconds pod needs to terminate gracefully
    terminationGracePeriodSeconds: 30
    # @schema {"name": "gateway.backup.podPriority", "type": "object", "anchor": "podPriority"}
    podPriority:
      # @schema {"name": "gateway.backup.podPriority.enabled", "type": "boolean"}
      # gateway.backup.podPriority.enabled -- gateway pod PriorityClass enabled
      enabled: true
      # @schema {"name": "gateway.backup.podPriority.value", "type": "integer"}
      # gateway.backup.podPriority.value -- gateway pod PriorityClass value
      value: 1000000
    # @schema {"name": "gateway.backup.annotations", "type": "object"}
    # gateway.backup.annotations -- deployment annotations
    annotations: {}
    # @schema {"name": "gateway.backup.podAnnotations", "type": "object"}
    # gateway.backup.podAnnotations -- pod annotations
    podAnnotations: {}
    # @schema {"name": "gateway.backup.service", "type": "object", "anchor": "service"}
    service:
      # @schema {"name": "gateway.backup.service.annotations", "type": "object"}
      # gateway.backup.service.annotations -- service annotations
      annotations: {}
      # @schema {"name": "gateway.backup.service.labels", "type": "object"}
      # gateway.backup.service.labels -- service labels
      labels: {}
    # @schema {"name": "gateway.backup.hpa", "type": "object", "anchor": "hpa"}
    hpa:
      # @schema {"name": "gateway.backup.hpa.enabled", "type": "boolean"}
      # gateway.backup.hpa.enabled -- HPA enabled
      enabled: true
      # @schema {"name": "gateway.backup.hpa.targetCPUUtilizationPercentage", "type": "integer"}
      # gateway.backup.hpa.targetCPUUtilizationPercentage -- HPA CPU utilization percentage
      targetCPUUtilizationPercentage: 80
    # @schema {"name": "gateway.backup.image", "type": "object", "anchor": "image"}
    image:
      # @schema {"name": "gateway.backup.image.repository", "type": "string"}
      # gateway.backup.image.repository -- image repository
      repository: vdaas/vald-gateway-backup
      # @schema {"name": "gateway.backup.image.tag", "type": "string"}
      # gateway.backup.image.tag -- image tag (overrides defaults.image.tag)
      tag: ""
      # @schema {"name": "gateway.backup.image.pullPolicy", "type": "string", "enum": ["Always", "Never", "IfNotPresent"]}
      # gateway.backup.image.pullPolicy -- image pull policy
      pullPolicy: Always
    # @schema {"name": "gateway.backup.rollingUpdate", "type": "object", "anchor": "rollingUpdate"}
    rollingUpdate:
      # @schema {"name": "gateway.backup.rollingUpdate.maxSurge", "type": "string"}
      # gateway.backup.rollingUpdate.maxSurge -- max surge of rolling update
      maxSurge: 25%
      # @schema {"name": "gateway.backup.rollingUpdate.maxUnavailable", "type": "string"}
      # gateway.backup.rollingUpdate.maxUnavailable -- max unavailable of rolling update
      maxUnavailable: 25%
    # @schema {"name": "gateway.backup.initContainers", "type": "array", "items": {"type": "object"}, "anchor": "initContainers"}
    # gateway.backup.initContainers -- init containers
    initContainers:
      - type: wait-for
        name: wait-for-manager-compressor
        target: compressor
        image: busybox
        sleepDuration: 2
      - type: wait-for
        name: wait-for-gateway-lb
        target: gateway-lb
        image: busybox
        sleepDuration: 2
    # @schema {"name": "gateway.backup.env", "type": "array", "items": {"type": "object"}, "anchor": "env"}
    # gateway.backup.env -- environment variables
    env: []
    # @schema {"name": "gateway.backup.volumeMounts", "type": "array", "items": {"type": "object"}, "anchor": "volumeMounts"}
    # gateway.backup.volumeMounts -- volume mounts
    volumeMounts: []
    # @schema {"name": "gateway.backup.volumes", "type": "array", "items": {"type": "object"}, "anchor": "volumes"}
    # gateway.backup.volumes -- volumes
    volumes: []
    # @schema {"name": "gateway.backup.nodeName", "type": "string"}
    # gateway.backup.nodeName -- node name
    nodeName: ""
    # @schema {"name": "gateway.backup.nodeSelector", "type": "object", "anchor": "nodeSelector"}
    # gateway.backup.nodeSelector -- node selector
    nodeSelector: {}
    # @schema {"name": "gateway.backup.tolerations", "type": "array", "items": {"type": "object"}, "anchor": "tolerations"}
    # gateway.backup.tolerations -- tolerations
    tolerations: []
    # @schema {"name": "gateway.backup.affinity", "type": "object", "anchor": "affinity"}
    affinity:
      # @schema {"name": "gateway.backup.affinity.nodeAffinity", "type": "object"}
      nodeAffinity:
        # @schema {"name": "gateway.backup.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.backup.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution -- node affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # @schema {"name": "gateway.backup.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "object"}
        requiredDuringSchedulingIgnoredDuringExecution:
          # @schema {"name": "gateway.backup.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms", "type": "array", "items": {"type": "object"}}
          # gateway.backup.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms -- node affinity required node selectors
          nodeSelectorTerms: []
      # @schema {"name": "gateway.backup.affinity.podAffinity", "type": "object"}
      podAffinity:
        # @schema {"name": "gateway.backup.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.backup.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # @schema {"name": "gateway.backup.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.backup.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
      # @schema {"name": "gateway.backup.affinity.podAntiAffinity", "type": "object"}
      podAntiAffinity:
        # @schema {"name": "gateway.backup.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.backup.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              topologyKey: kubernetes.io/hostname
              labelSelector:
                matchExpressions:
                  - key: app
                    operator: In
                    values:
                      - vald-gateway-backup
        # @schema {"name": "gateway.backup.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.backup.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
    # @schema {"name": "gateway.backup.topologySpreadConstraints", "type": "array", "items": {"type": "object"}, "anchor": "topologySpreadConstraints"}
    # gateway.backup.topologySpreadConstraints -- topology spread constraints of gateway pods
    topologySpreadConstraints: []
    # @schema {"name": "gateway.backup.server_config", "alias": "server_config"}
    # gateway.backup.server_config -- server config (overrides defaults.server_config)
    server_config:
      servers:
        rest: {}
        grpc: {}
      healths:
        liveness: {}
        readiness: {}
      metrics:
        pprof: {}
        prometheus: {}
    # @schema {"name": "gateway.backup.observability", "alias": "observability"}
    # gateway.backup.observability -- observability config (overrides defaults.observability)
    observability:
      jaeger:
        service_name: vald-gateway-backup
      stackdriver:
        profiler:
          service: vald-gateway-backup
    # @schema {"name": "gateway.backup.ingress", "type": "object"}
    ingress:
      # @schema {"name": "gateway.backup.ingress.enabled", "type": "boolean"}
      # gateway.backup.ingress.enabled -- gateway ingress enabled
      enabled: false
      # @schema {"name": "gateway.backup.ingress.annotations", "type": "object"}
      # gateway.backup.ingress.annotations -- annotations for ingress
      annotations:
        nginx.ingress.kubernetes.io/grpc-backend: "true"
      # @schema {"name": "gateway.backup.ingress.host", "type": "string"}
      # gateway.backup.ingress.host -- ingress hostname
      host: backup.gateway.vald.vdaas.org
      # @schema {"name": "gateway.backup.ingress.servicePort", "type": "string"}
      # gateway.backup.ingress.servicePort -- service port to be exposed by ingress
      servicePort: grpc
    # @schema {"name": "gateway.backup.resources", "type": "object", "anchor": "resources"}
    # gateway.backup.resources -- compute resources
    resources:
      # @schema {"name": "gateway.backup.resources.requests", "type": "object"}
      requests:
        cpu: 200m
        memory: 150Mi
      # @schema {"name": "gateway.backup.resources.limits", "type": "object"}
      limits:
        cpu: 2000m
        memory: 700Mi
    # @schema {"name": "gateway.backup.gateway_config", "type": "object"}
    gateway_config:
      # @schema {"name": "gateway.backup.gateway_config.client", "alias": "grpc.client"}
      # gateway.backup.gateway_config.client -- gRPC client for next gateway (overrides defaults.grpc.client)
      client:
        addrs:
          - "vald-gateway-lb.vald.svc.cluster.local"
      # @schema {"name": "gateway.backup.gateway_config.backup", "type": "object"}
      backup:
        # @schema {"name": "gateway.backup.gateway_config.backup.client", "alias": "grpc.client"}
        # gateway.backup.gateway_config.backup.client -- gRPC client for backup (overrides defaults.grpc.client)
        client: {}
  # @schema {"name": "gateway.filter", "type": "object"}
  filter:
    # @schema {"name": "gateway.filter.enabled", "type": "boolean"}
    # gateway.filter.enabled -- gateway enabled
    enabled: false
    # @schema {"name": "gateway.filter.version", "type": "string", "pattern": "^v[0-9]+\\.[0-9]+\\.[0-9]$", "anchor": "version"}
    # gateway.filter.version -- version of gateway config
    version: v0.0.0
    # @schema {"name": "gateway.filter.time_zone", "type": "string"}
    # gateway.filter.time_zone -- Time zone
    time_zone: ""
    # @schema {"name": "gateway.filter.logging", "alias": "logging"}
    # gateway.filter.logging -- logging config (overrides defaults.logging)
    logging: {}
    # @schema {"name": "gateway.filter.name", "type": "string"}
    # gateway.filter.name -- name of filter gateway deployment
    name: vald-gateway-filter
    # @schema {"name": "gateway.filter.kind", "type": "string", "enum": ["Deployment", "DaemonSet"]}
    # gateway.filter.kind -- deployment kind: Deployment or DaemonSet
    kind: Deployment
    # @schema {"name": "gateway.filter.serviceType", "type": "string", "enum": ["ClusterIP", "LoadBalancer", "NodePort"]}
    # gateway.filter.serviceType -- service type: ClusterIP, LoadBalancer or NodePort
    serviceType: ClusterIP
    # @schema {"name": "gateway.filter.externalTrafficPolicy", "type": "string"}
    # gateway.filter.externalTrafficPolicy -- external traffic policy (can be specified when service type is LoadBalancer or NodePort) : Cluster or Local
    externalTrafficPolicy: ""
    # @schema {"name": "gateway.filter.progressDeadlineSeconds", "type": "integer"}
    # gateway.filter.progressDeadlineSeconds -- progress deadline seconds
    progressDeadlineSeconds: 600
    # @schema {"name": "gateway.filter.minReplicas", "type": "integer", "minimum": 0}
    # gateway.filter.minReplicas -- minimum number of replicas.
    # if HPA is disabled, the replicas will be set to this value
    minReplicas: 3
    # @schema {"name": "gateway.filter.maxReplicas", "type": "integer", "minimum": 0}
    # gateway.filter.maxReplicas -- maximum number of replicas.
    # if HPA is disabled, this value will be ignored.
    maxReplicas: 9
    # @schema {"name": "gateway.filter.maxUnavailable", "type": "string"}
    # gateway.filter.maxUnavailable -- maximum number of unavailable replicas
    maxUnavailable: 50%
    # @schema {"name": "gateway.filter.revisionHistoryLimit", "type": "integer", "minimum": 0}
    # gateway.filter.revisionHistoryLimit -- number of old history to retain to allow rollback
    revisionHistoryLimit: 2
    # @schema {"name": "gateway.filter.terminationGracePeriodSeconds", "type": "integer", "minimum": 0}
    # gateway.filter.terminationGracePeriodSeconds -- duration in seconds pod needs to terminate gracefully
    terminationGracePeriodSeconds: 30
    # @schema {"name": "gateway.filter.podPriority", "type": "object", "anchor": "podPriority"}
    podPriority:
      # @schema {"name": "gateway.filter.podPriority.enabled", "type": "boolean"}
      # gateway.filter.podPriority.enabled -- gateway pod PriorityClass enabled
      enabled: true
      # @schema {"name": "gateway.filter.podPriority.value", "type": "integer"}
      # gateway.filter.podPriority.value -- gateway pod PriorityClass value
      value: 1000000
    # @schema {"name": "gateway.filter.annotations", "type": "object"}
    # gateway.filter.annotations -- deployment annotations
    annotations: {}
    # @schema {"name": "gateway.filter.podAnnotations", "type": "object"}
    # gateway.filter.podAnnotations -- pod annotations
    podAnnotations: {}
    # @schema {"name": "gateway.filter.service", "type": "object", "anchor": "service"}
    service:
      # @schema {"name": "gateway.filter.service.annotations", "type": "object"}
      # gateway.filter.service.annotations -- service annotations
      annotations: {}
      # @schema {"name": "gateway.filter.service.labels", "type": "object"}
      # gateway.filter.service.labels -- service labels
      labels: {}
    # @schema {"name": "gateway.filter.hpa", "type": "object", "anchor": "hpa"}
    hpa:
      # @schema {"name": "gateway.filter.hpa.enabled", "type": "boolean"}
      # gateway.filter.hpa.enabled -- HPA enabled
      enabled: true
      # @schema {"name": "gateway.filter.hpa.targetCPUUtilizationPercentage", "type": "integer"}
      # gateway.filter.hpa.targetCPUUtilizationPercentage -- HPA CPU utilization percentage
      targetCPUUtilizationPercentage: 80
    # @schema {"name": "gateway.filter.image", "type": "object", "anchor": "image"}
    image:
      # @schema {"name": "gateway.filter.image.repository", "type": "string"}
      # gateway.filter.image.repository -- image repository
      repository: vdaas/vald-gateway-filter
      # @schema {"name": "gateway.filter.image.tag", "type": "string"}
      # gateway.filter.image.tag -- image tag (overrides defaults.image.tag)
      tag: ""
      # @schema {"name": "gateway.filter.image.pullPolicy", "type": "string", "enum": ["Always", "Never", "IfNotPresent"]}
      # gateway.filter.image.pullPolicy -- image pull policy
      pullPolicy: Always
    # @schema {"name": "gateway.filter.rollingUpdate", "type": "object", "anchor": "rollingUpdate"}
    rollingUpdate:
      # @schema {"name": "gateway.filter.rollingUpdate.maxSurge", "type": "string"}
      # gateway.filter.rollingUpdate.maxSurge -- max surge of rolling update
      maxSurge: 25%
      # @schema {"name": "gateway.filter.rollingUpdate.maxUnavailable", "type": "string"}
      # gateway.filter.rollingUpdate.maxUnavailable -- max unavailable of rolling update
      maxUnavailable: 25%
    # @schema {"name": "gateway.filter.initContainers", "type": "array", "items": {"type": "object"}, "anchor": "initContainers"}
    # gateway.filter.initContainers -- init containers
    initContainers:
      - type: wait-for
        name: wait-for-gateway-meta
        target: gateway-meta
        image: busybox
        sleepDuration: 2
    # @schema {"name": "gateway.filter.env", "type": "array", "items": {"type": "object"}, "anchor": "env"}
    # gateway.filter.env -- environment variables
    env: []
    # @schema {"name": "gateway.filter.volumeMounts", "type": "array", "items": {"type": "object"}, "anchor": "volumeMounts"}
    # gateway.filter.volumeMounts -- volume mounts
    volumeMounts: []
    # @schema {"name": "gateway.filter.volumes", "type": "array", "items": {"type": "object"}, "anchor": "volumes"}
    # gateway.filter.volumes -- volumes
    volumes: []
    # @schema {"name": "gateway.filter.nodeName", "type": "string"}
    # gateway.filter.nodeName -- node name
    nodeName: ""
    # @schema {"name": "gateway.filter.nodeSelector", "type": "object", "anchor": "nodeSelector"}
    # gateway.filter.nodeSelector -- node selector
    nodeSelector: {}
    # @schema {"name": "gateway.filter.tolerations", "type": "array", "items": {"type": "object"}, "anchor": "tolerations"}
    # gateway.filter.tolerations -- tolerations
    tolerations: []
    # @schema {"name": "gateway.filter.affinity", "type": "object", "anchor": "affinity"}
    affinity:
      # @schema {"name": "gateway.filter.affinity.nodeAffinity", "type": "object"}
      nodeAffinity:
        # @schema {"name": "gateway.filter.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.filter.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution -- node affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # @schema {"name": "gateway.filter.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "object"}
        requiredDuringSchedulingIgnoredDuringExecution:
          # @schema {"name": "gateway.filter.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms", "type": "array", "items": {"type": "object"}}
          # gateway.filter.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms -- node affinity required node selectors
          nodeSelectorTerms: []
      # @schema {"name": "gateway.filter.affinity.podAffinity", "type": "object"}
      podAffinity:
        # @schema {"name": "gateway.filter.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.filter.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # @schema {"name": "gateway.filter.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.filter.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
      # @schema {"name": "gateway.filter.affinity.podAntiAffinity", "type": "object"}
      podAntiAffinity:
        # @schema {"name": "gateway.filter.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.filter.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              topologyKey: kubernetes.io/hostname
              labelSelector:
                matchExpressions:
                  - key: app
                    operator: In
                    values:
                      - vald-gateway-filter
        # @schema {"name": "gateway.filter.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.filter.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
    # @schema {"name": "gateway.filter.topologySpreadConstraints", "type": "array", "items": {"type": "object"}, "anchor": "topologySpreadConstraints"}
    # gateway.filter.topologySpreadConstraints -- topology spread constraints of gateway pods
    topologySpreadConstraints: []
    # @schema {"name": "gateway.filter.server_config", "alias": "server_config"}
    # gateway.filter.server_config -- server config (overrides defaults.server_config)
    server_config:
      servers:
        rest: {}
        grpc: {}
      healths:
        liveness: {}
        readiness: {}
      metrics:
        pprof: {}
        prometheus: {}
    # @schema {"name": "gateway.filter.observability", "alias": "observability"}
    # gateway.filter.observability -- observability config (overrides defaults.observability)
    observability:
      jaeger:
        service_name: vald-gateway-filter
      stackdriver:
        profiler:
          service: vald-gateway-filter
    # @schema {"name": "gateway.filter.ingress", "type": "object"}
    ingress:
      # @schema {"name": "gateway.filter.ingress.enabled", "type": "boolean"}
      # gateway.filter.ingress.enabled -- gateway ingress enabled
      enabled: false
      # @schema {"name": "gateway.filter.ingress.annotations", "type": "object"}
      # gateway.filter.ingress.annotations -- annotations for ingress
      annotations:
        nginx.ingress.kubernetes.io/grpc-backend: "true"
      # @schema {"name": "gateway.filter.ingress.host", "type": "string"}
      # gateway.filter.ingress.host -- ingress hostname
      host: filter.gateway.vald.vdaas.org
      # @schema {"name": "gateway.filter.ingress.servicePort", "type": "string"}
      # gateway.filter.ingress.servicePort -- service port to be exposed by ingress
      servicePort: grpc
    # @schema {"name": "gateway.filter.resources", "type": "object", "anchor": "resources"}
    # gateway.filter.resources -- compute resources
    resources:
      # @schema {"name": "gateway.filter.resources.requests", "type": "object"}
      requests:
        cpu: 200m
        memory: 150Mi
      # @schema {"name": "gateway.filter.resources.limits", "type": "object"}
      limits:
        cpu: 2000m
        memory: 700Mi
    # @schema {"name": "gateway.filter.gateway_config", "type": "object"}
    gateway_config:
      # @schema {"name": "gateway.filter.gateway_config.client", "alias": "grpc.client"}
      # gateway.filter.gateway_config.client -- gRPC client for next gateway (overrides defaults.grpc.client)
      client:
        addrs:
          - "vald-gateway-meta.vald.svc.cluster.local"
      # @schema {"name": "gateway.filter.gateway_config.ingress_filter", "type": "object"}
      ingress_filter:
        # @schema {"name": "gateway.filter.gateway_config.ingress_filter.client", "alias": "grpc.client"}
        # gateway.filter.gateway_config.ingress_filter.client -- gRPC client for ingress filters (overrides defaults.grpc.client)
        client: {}
        # @schema {"name": "gateway.filter.gateway_config.ingress_filter.search", "type": "array", "items": {"type": "string"}}
        # gateway.filter.gateway_config.ingress_filter.search -- ingress filters for search operation
        search: []
        # @schema {"name": "gateway.filter.gateway_config.ingress_filter.insert", "type": "array", "items": {"type": "string"}}
        # gateway.filter.gateway_config.ingress_filter.insert -- ingress filters for insert operation
        insert: []
        # @schema {"name": "gateway.filter.gateway_config.ingress_filter.update", "type": "array", "items": {"type": "string"}}
        # gateway.filter.gateway_config.ingress_filter.update -- ingress filters for update operation
        update: []
        # @schema {"name": "gateway.filter.gateway_config.ingress_filter.upsert", "type": "array", "items": {"type": "string"}}
        # gateway.filter.gateway_config.ingress_filter.upsert -- ingress filters for upsert operation
        upsert: []
      # @schema {"name": "gateway.filter.gateway_config.egress_filter", "type": "object"}
      egress_filter:
        # @schema {"name": "gateway.filter.gateway_config.egress_filter.client", "alias": "grpc.client"}
        # gateway.filter.gateway_config.egress_filter.client -- gRPC client for egress filter (overrides defaults.grpc.client)
        client: {}
  # @schema {"name": "gateway.lb", "type": "object"}
  lb:
    # @schema {"name": "gateway.lb.enabled", "type": "boolean"}
    # gateway.lb.enabled -- gateway enabled
    enabled: false
    # @schema {"name": "gateway.lb.version", "type": "string", "pattern": "^v[0-9]+\\.[0-9]+\\.[0-9]$", "anchor": "version"}
    # gateway.lb.version -- version of gateway config
    version: v0.0.0
    # @schema {"name": "gateway.lb.time_zone", "type": "string"}
    # gateway.lb.time_zone -- Time zone
    time_zone: ""
    # @schema {"name": "gateway.lb.logging", "alias": "logging"}
    # gateway.lb.logging -- logging config (overrides defaults.logging)
    logging: {}
    # @schema {"name": "gateway.lb.name", "type": "string"}
    # gateway.lb.name -- name of gateway deployment
    name: vald-gateway-lb
    # @schema {"name": "gateway.lb.kind", "type": "string", "enum": ["Deployment", "DaemonSet"]}
    # gateway.lb.kind -- deployment kind: Deployment or DaemonSet
    kind: Deployment
    # @schema {"name": "gateway.lb.serviceType", "type": "string", "enum": ["ClusterIP", "LoadBalancer", "NodePort"]}
    # gateway.lb.serviceType -- service type: ClusterIP, LoadBalancer or NodePort
    serviceType: ClusterIP
    # @schema {"name": "gateway.lb.externalTrafficPolicy", "type": "string"}
    # gateway.lb.externalTrafficPolicy -- external traffic policy (can be specified when service type is LoadBalancer or NodePort) : Cluster or Local
    externalTrafficPolicy: ""
    # @schema {"name": "gateway.lb.progressDeadlineSeconds", "type": "integer"}
    # gateway.lb.progressDeadlineSeconds -- progress deadline seconds
    progressDeadlineSeconds: 600
    # @schema {"name": "gateway.lb.minReplicas", "type": "integer", "minimum": 0}
    # gateway.lb.minReplicas -- minimum number of replicas.
    # if HPA is disabled, the replicas will be set to this value
    minReplicas: 3
    # @schema {"name": "gateway.lb.maxReplicas", "type": "integer", "minimum": 0}
    # gateway.lb.maxReplicas -- maximum number of replicas.
    # if HPA is disabled, this value will be ignored.
    maxReplicas: 9
    # @schema {"name": "gateway.lb.maxUnavailable", "type": "string"}
    # gateway.lb.maxUnavailable -- maximum number of unavailable replicas
    maxUnavailable: 50%
    # @schema {"name": "gateway.lb.revisionHistoryLimit", "type": "integer", "minimum": 0}
    # gateway.lb.revisionHistoryLimit -- number of old history to retain to allow rollback
    revisionHistoryLimit: 2
    # @schema {"name": "gateway.lb.terminationGracePeriodSeconds", "type": "integer", "minimum": 0}
    # gateway.lb.terminationGracePeriodSeconds -- duration in seconds pod needs to terminate gracefully
    terminationGracePeriodSeconds: 30
    # @schema {"name": "gateway.lb.podPriority", "type": "object", "anchor": "podPriority"}
    podPriority:
      # @schema {"name": "gateway.lb.podPriority.enabled", "type": "boolean"}
      # gateway.lb.podPriority.enabled -- gateway pod PriorityClass enabled
      enabled: true
      # @schema {"name": "gateway.lb.podPriority.value", "type": "integer"}
      # gateway.lb.podPriority.value -- gateway pod PriorityClass value
      value: 1000000
    # @schema {"name": "gateway.lb.annotations", "type": "object"}
    # gateway.lb.annotations -- deployment annotations
    annotations: {}
    # @schema {"name": "gateway.lb.podAnnotations", "type": "object"}
    # gateway.lb.podAnnotations -- pod annotations
    podAnnotations: {}
    # @schema {"name": "gateway.lb.service", "type": "object", "anchor": "service"}
    service:
      # @schema {"name": "gateway.lb.service.annotations", "type": "object"}
      # gateway.lb.service.annotations -- service annotations
      annotations: {}
      # @schema {"name": "gateway.lb.service.labels", "type": "object"}
      # gateway.lb.service.labels -- service labels
      labels: {}
    # @schema {"name": "gateway.lb.hpa", "type": "object", "anchor": "hpa"}
    hpa:
      # @schema {"name": "gateway.lb.hpa.enabled", "type": "boolean"}
      # gateway.lb.hpa.enabled -- HPA enabled
      enabled: true
      # @schema {"name": "gateway.lb.hpa.targetCPUUtilizationPercentage", "type": "integer"}
      # gateway.lb.hpa.targetCPUUtilizationPercentage -- HPA CPU utilization percentage
      targetCPUUtilizationPercentage: 80
    # @schema {"name": "gateway.lb.image", "type": "object", "anchor": "image"}
    image:
      # @schema {"name": "gateway.lb.image.repository", "type": "string"}
      # gateway.lb.image.repository -- image repository
      repository: vdaas/vald-gateway-lb
      # @schema {"name": "gateway.lb.image.tag", "type": "string"}
      # gateway.lb.image.tag -- image tag (overrides defaults.image.tag)
      tag: ""
      # @schema {"name": "gateway.lb.image.pullPolicy", "type": "string", "enum": ["Always", "Never", "IfNotPresent"]}
      # gateway.lb.image.pullPolicy -- image pull policy
      pullPolicy: Always
    # @schema {"name": "gateway.lb.rollingUpdate", "type": "object", "anchor": "rollingUpdate"}
    rollingUpdate:
      # @schema {"name": "gateway.lb.rollingUpdate.maxSurge", "type": "string"}
      # gateway.lb.rollingUpdate.maxSurge -- max surge of rolling update
      maxSurge: 25%
      # @schema {"name": "gateway.lb.rollingUpdate.maxUnavailable", "type": "string"}
      # gateway.lb.rollingUpdate.maxUnavailable -- max unavailable of rolling update
      maxUnavailable: 25%
    # @schema {"name": "gateway.lb.initContainers", "type": "array", "items": {"type": "object"}, "anchor": "initContainers"}
    # gateway.lb.initContainers -- init containers
    initContainers:
      - type: wait-for
        name: wait-for-discoverer
        target: discoverer
        image: busybox
        sleepDuration: 2
      - type: wait-for
        name: wait-for-agent
        target: agent
        image: busybox
        sleepDuration: 2
    # @schema {"name": "gateway.lb.env", "type": "array", "items": {"type": "object"}, "anchor": "env"}
    # gateway.lb.env -- environment variables
    env:
      # - name: MY_NODE_NAME
      #   valueFrom:
      #     fieldRef:
      #       fieldPath: spec.nodeName
      - name: MY_POD_NAMESPACE
        valueFrom:
          fieldRef:
            fieldPath: metadata.namespace
    # @schema {"name": "gateway.lb.volumeMounts", "type": "array", "items": {"type": "object"}, "anchor": "volumeMounts"}
    # gateway.lb.volumeMounts -- volume mounts
    volumeMounts: []
    # @schema {"name": "gateway.lb.volumes", "type": "array", "items": {"type": "object"}, "anchor": "volumes"}
    # gateway.lb.volumes -- volumes
    volumes: []
    # @schema {"name": "gateway.lb.nodeName", "type": "string"}
    # gateway.lb.nodeName -- node name
    nodeName: ""
    # @schema {"name": "gateway.lb.nodeSelector", "type": "object", "anchor": "nodeSelector"}
    # gateway.lb.nodeSelector -- node selector
    nodeSelector: {}
    # @schema {"name": "gateway.lb.tolerations", "type": "array", "items": {"type": "object"}, "anchor": "tolerations"}
    # gateway.lb.tolerations -- tolerations
    tolerations: []
    # @schema {"name": "gateway.lb.affinity", "type": "object", "anchor": "affinity"}
    affinity:
      # @schema {"name": "gateway.lb.affinity.nodeAffinity", "type": "object"}
      nodeAffinity:
        # @schema {"name": "gateway.lb.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.lb.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution -- node affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # @schema {"name": "gateway.lb.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "object"}
        requiredDuringSchedulingIgnoredDuringExecution:
          # @schema {"name": "gateway.lb.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms", "type": "array", "items": {"type": "object"}}
          # gateway.lb.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms -- node affinity required node selectors
          nodeSelectorTerms: []
      # @schema {"name": "gateway.lb.affinity.podAffinity", "type": "object"}
      podAffinity:
        # @schema {"name": "gateway.lb.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.lb.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # @schema {"name": "gateway.lb.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.lb.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
      # @schema {"name": "gateway.lb.affinity.podAntiAffinity", "type": "object"}
      podAntiAffinity:
        # @schema {"name": "gateway.lb.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.lb.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              topologyKey: kubernetes.io/hostname
              labelSelector:
                matchExpressions:
                  - key: app
                    operator: In
                    values:
                      - vald-gateway-lb
        # @schema {"name": "gateway.lb.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.lb.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
    # @schema {"name": "gateway.lb.topologySpreadConstraints", "type": "array", "items": {"type": "object"}, "anchor": "topologySpreadConstraints"}
    # gateway.lb.topologySpreadConstraints -- topology spread constraints of gateway pods
    topologySpreadConstraints: []
    # @schema {"name": "gateway.lb.server_config", "alias": "server_config"}
    # gateway.lb.server_config -- server config (overrides defaults.server_config)
    server_config:
      servers:
        rest: {}
        grpc: {}
      healths:
        liveness: {}
        readiness: {}
      metrics:
        pprof: {}
        prometheus: {}
    # @schema {"name": "gateway.lb.observability", "alias": "observability"}
    # gateway.lb.observability -- observability config (overrides defaults.observability)
    observability:
      jaeger:
        service_name: vald-gateway-lb
      stackdriver:
        profiler:
          service: vald-gateway-lb
    # @schema {"name": "gateway.lb.ingress", "type": "object"}
    ingress:
      # @schema {"name": "gateway.lb.ingress.enabled", "type": "boolean"}
      # gateway.lb.ingress.enabled -- gateway ingress enabled
      enabled: false
      # @schema {"name": "gateway.lb.ingress.annotations", "type": "object"}
      # gateway.lb.ingress.annotations -- annotations for ingress
      annotations:
        nginx.ingress.kubernetes.io/grpc-backend: "true"
      # @schema {"name": "gateway.lb.ingress.host", "type": "string"}
      # gateway.lb.ingress.host -- ingress hostname
      host: lb.gateway.vald.vdaas.org
      # @schema {"name": "gateway.lb.ingress.servicePort", "type": "string"}
      # gateway.lb.ingress.servicePort -- service port to be exposed by ingress
      servicePort: grpc
    # @schema {"name": "gateway.lb.resources", "type": "object", "anchor": "resources"}
    # gateway.lb.resources -- compute resources
    resources:
      # @schema {"name": "gateway.lb.resources.requests", "type": "object"}
      requests:
        cpu: 200m
        memory: 150Mi
      # @schema {"name": "gateway.lb.resources.limits", "type": "object"}
      limits:
        cpu: 2000m
        memory: 700Mi
    # @schema {"name": "gateway.lb.gateway_config", "type": "object"}
    gateway_config:
      # @schema {"name": "gateway.lb.gateway_config.agent_namespace", "type": "string"}
      # gateway.lb.gateway_config.agent_namespace -- agent namespace
      agent_namespace: _MY_POD_NAMESPACE_
      # @schema {"name": "gateway.lb.gateway_config.node_namespace", "type": "string"}
      # gateway.lb.gateway_config.node_name -- node name
      node_name: "" # _MY_NODE_NAME_
      # @schema {"name": "gateway.lb.gateway_config.index_replica", "type": "integer", "minimum": 1}
      # gateway.lb.gateway_config.index_replica -- number of index replica
      index_replica: 5
      # @schema {"name": "gateway.lb.gateway_config.discoverer", "type": "object"}
      discoverer:
        # @schema {"name": "gateway.lb.gateway_config.discoverer.duration", "type": "string"}
        # gateway.lb.discoverer.duration -- discoverer duration
        duration: 200ms
        # @schema {"name": "gateway.lb.gateway_config.discoverer.discover_client", "alias": "grpc.client"}
        # gateway.lb.gateway_config.discoverer.discover_client -- gRPC client for discoverer (overrides defaults.grpc.client)
        discover_client: {}
        # @schema {"name": "gateway.lb.gateway_config.discoverer.agent_client", "alias": "grpc.client"}
        # gateway.lb.gateway_config.discoverer.agent_client -- gRPC client for agents (overrides defaults.grpc.client)
        agent_client: {}
  # @schema {"name": "gateway.meta", "type": "object"}
  meta:
    # @schema {"name": "gateway.meta.enabled", "type": "boolean"}
    # gateway.meta.enabled -- gateway enabled
    enabled: true
    # @schema {"name": "gateway.meta.version", "type": "string", "pattern": "^v[0-9]+\\.[0-9]+\\.[0-9]$", "anchor": "version"}
    # gateway.meta.version -- version of gateway config
    version: v0.0.0
    # @schema {"name": "gateway.meta.time_zone", "type": "string"}
    # gateway.meta.time_zone -- Time zone
    time_zone: ""
    # @schema {"name": "gateway.meta.logging", "alias": "logging"}
    # gateway.meta.logging -- logging config (overrides defaults.logging)
    logging: {}
    # @schema {"name": "gateway.meta.name", "type": "string"}
    # gateway.meta.name -- name of gateway deployment
    name: vald-gateway-meta
    # @schema {"name": "gateway.meta.kind", "type": "string", "enum": ["Deployment", "DaemonSet"]}
    # gateway.meta.kind -- deployment kind: Deployment or DaemonSet
    kind: Deployment
    # @schema {"name": "gateway.meta.serviceType", "type": "string", "enum": ["ClusterIP", "LoadBalancer", "NodePort"]}
    # gateway.meta.serviceType -- service type: ClusterIP, LoadBalancer or NodePort
    serviceType: ClusterIP
    # @schema {"name": "gateway.meta.externalTrafficPolicy", "type": "string"}
    # gateway.meta.externalTrafficPolicy -- external traffic policy (can be specified when service type is LoadBalancer or NodePort) : Cluster or Local
    externalTrafficPolicy: ""
    # @schema {"name": "gateway.meta.progressDeadlineSeconds", "type": "integer"}
    # gateway.meta.progressDeadlineSeconds -- progress deadline seconds
    progressDeadlineSeconds: 600
    # @schema {"name": "gateway.meta.minReplicas", "type": "integer", "minimum": 0}
    # gateway.meta.minReplicas -- minimum number of replicas.
    # if HPA is disabled, the replicas will be set to this value
    minReplicas: 3
    # @schema {"name": "gateway.meta.maxReplicas", "type": "integer", "minimum": 0}
    # gateway.meta.maxReplicas -- maximum number of replicas.
    # if HPA is disabled, this value will be ignored.
    maxReplicas: 9
    # @schema {"name": "gateway.meta.maxUnavailable", "type": "string"}
    # gateway.meta.maxUnavailable -- maximum number of unavailable replicas
    maxUnavailable: 50%
    # @schema {"name": "gateway.meta.revisionHistoryLimit", "type": "integer", "minimum": 0}
    # gateway.meta.revisionHistoryLimit -- number of old history to retain to allow rollback
    revisionHistoryLimit: 2
    # @schema {"name": "gateway.meta.terminationGracePeriodSeconds", "type": "integer", "minimum": 0}
    # gateway.meta.terminationGracePeriodSeconds -- duration in seconds pod needs to terminate gracefully
    terminationGracePeriodSeconds: 30
    # @schema {"name": "gateway.meta.podPriority", "type": "object", "anchor": "podPriority"}
    podPriority:
      # @schema {"name": "gateway.meta.podPriority.enabled", "type": "boolean"}
      # gateway.meta.podPriority.enabled -- gateway pod PriorityClass enabled
      enabled: true
      # @schema {"name": "gateway.meta.podPriority.value", "type": "integer"}
      # gateway.meta.podPriority.value -- gateway pod PriorityClass value
      value: 1000000
    # @schema {"name": "gateway.meta.annotations", "type": "object"}
    # gateway.meta.annotations -- deployment annotations
    annotations: {}
    # @schema {"name": "gateway.meta.podAnnotations", "type": "object"}
    # gateway.meta.podAnnotations -- pod annotations
    podAnnotations: {}
    # @schema {"name": "gateway.meta.service", "type": "object", "anchor": "service"}
    service:
      # @schema {"name": "gateway.meta.service.annotations", "type": "object"}
      # gateway.meta.service.annotations -- service annotations
      annotations: {}
      # @schema {"name": "gateway.meta.service.labels", "type": "object"}
      # gateway.meta.service.labels -- service labels
      labels: {}
    # @schema {"name": "gateway.meta.hpa", "type": "object", "anchor": "hpa"}
    hpa:
      # @schema {"name": "gateway.meta.hpa.enabled", "type": "boolean"}
      # gateway.meta.hpa.enabled -- HPA enabled
      enabled: true
      # @schema {"name": "gateway.meta.hpa.targetCPUUtilizationPercentage", "type": "integer"}
      # gateway.meta.hpa.targetCPUUtilizationPercentage -- HPA CPU utilization percentage
      targetCPUUtilizationPercentage: 80
    # @schema {"name": "gateway.meta.image", "type": "object", "anchor": "image"}
    image:
      # @schema {"name": "gateway.meta.image.repository", "type": "string"}
      # gateway.meta.image.repository -- image repository
      repository: vdaas/vald-gateway-meta
      # @schema {"name": "gateway.meta.image.tag", "type": "string"}
      # gateway.meta.image.tag -- image tag (overrides defaults.image.tag)
      tag: ""
      # @schema {"name": "gateway.meta.image.pullPolicy", "type": "string", "enum": ["Always", "Never", "IfNotPresent"]}
      # gateway.meta.image.pullPolicy -- image pull policy
      pullPolicy: Always
    # @schema {"name": "gateway.meta.rollingUpdate", "type": "object", "anchor": "rollingUpdate"}
    rollingUpdate:
      # @schema {"name": "gateway.meta.rollingUpdate.maxSurge", "type": "string"}
      # gateway.meta.rollingUpdate.maxSurge -- max surge of rolling update
      maxSurge: 25%
      # @schema {"name": "gateway.meta.rollingUpdate.maxUnavailable", "type": "string"}
      # gateway.meta.rollingUpdate.maxUnavailable -- max unavailable of rolling update
      maxUnavailable: 25%
    # @schema {"name": "gateway.meta.initContainers", "type": "array", "items": {"type": "object"}, "anchor": "initContainers"}
    # gateway.meta.initContainers -- init containers
    initContainers:
      - type: wait-for
        name: wait-for-meta
        target: meta
        image: busybox
        sleepDuration: 2
      - type: wait-for
        name: wait-for-gateway-backup
        target: gateway-backup
        image: busybox
        sleepDuration: 2
    # @schema {"name": "gateway.meta.env", "type": "array", "items": {"type": "object"}, "anchor": "env"}
    # gateway.meta.env -- environment variables
    env: []
    # @schema {"name": "gateway.meta.volumeMounts", "type": "array", "items": {"type": "object"}, "anchor": "volumeMounts"}
    # gateway.meta.volumeMounts -- volume mounts
    volumeMounts: []
    # @schema {"name": "gateway.meta.volumes", "type": "array", "items": {"type": "object"}, "anchor": "volumes"}
    # gateway.meta.volumes -- volumes
    volumes: []
    # @schema {"name": "gateway.meta.nodeName", "type": "string"}
    # gateway.meta.nodeName -- node name
    nodeName: ""
    # @schema {"name": "gateway.meta.nodeSelector", "type": "object", "anchor": "nodeSelector"}
    # gateway.meta.nodeSelector -- node selector
    nodeSelector: {}
    # @schema {"name": "gateway.meta.tolerations", "type": "array", "items": {"type": "object"}, "anchor": "tolerations"}
    # gateway.meta.tolerations -- tolerations
    tolerations: []
    # @schema {"name": "gateway.meta.affinity", "type": "object", "anchor": "affinity"}
    affinity:
      # @schema {"name": "gateway.meta.affinity.nodeAffinity", "type": "object"}
      nodeAffinity:
        # @schema {"name": "gateway.meta.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.meta.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution -- node affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # @schema {"name": "gateway.meta.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "object"}
        requiredDuringSchedulingIgnoredDuringExecution:
          # @schema {"name": "gateway.meta.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms", "type": "array", "items": {"type": "object"}}
          # gateway.meta.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms -- node affinity required node selectors
          nodeSelectorTerms: []
      # @schema {"name": "gateway.meta.affinity.podAffinity", "type": "object"}
      podAffinity:
        # @schema {"name": "gateway.meta.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.meta.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # @schema {"name": "gateway.meta.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.meta.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
      # @schema {"name": "gateway.meta.affinity.podAntiAffinity", "type": "object"}
      podAntiAffinity:
        # @schema {"name": "gateway.meta.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.meta.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              topologyKey: kubernetes.io/hostname
              labelSelector:
                matchExpressions:
                  - key: app
                    operator: In
                    values:
                      - vald-gateway-meta
        # @schema {"name": "gateway.meta.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution", "type": "array", "items": {"type": "object"}}
        # gateway.meta.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
    # @schema {"name": "gateway.meta.topologySpreadConstraints", "type": "array", "items": {"type": "object"}, "anchor": "topologySpreadConstraints"}
    # gateway.meta.topologySpreadConstraints -- topology spread constraints of gateway pods
    topologySpreadConstraints: []
    # @schema {"name": "gateway.meta.server_config", "alias": "server_config"}
    # gateway.meta.server_config -- server config (overrides defaults.server_config)
    server_config:
      servers:
        rest: {}
        grpc: {}
      healths:
        liveness: {}
        readiness: {}
      metrics:
        pprof: {}
        prometheus: {}
    # @schema {"name": "gateway.meta.observability", "alias": "observability"}
    # gateway.meta.observability -- observability config (overrides defaults.observability)
    observability:
      jaeger:
        service_name: vald-gateway-meta
      stackdriver:
        profiler:
          service: vald-gateway-meta
    # @schema {"name": "gateway.meta.ingress", "type": "object"}
    ingress:
      # @schema {"name": "gateway.meta.ingress.enabled", "type": "boolean"}
      # gateway.meta.ingress.enabled -- gateway ingress enabled
      enabled: false
      # @schema {"name": "gateway.meta.ingress.annotations", "type": "object"}
      # gateway.meta.ingress.annotations -- annotations for ingress
      annotations:
        nginx.ingress.kubernetes.io/grpc-backend: "true"
      # @schema {"name": "gateway.meta.ingress.host", "type": "string"}
      # gateway.meta.ingress.host -- ingress hostname
      host: meta.gateway.vald.vdaas.org
      # @schema {"name": "gateway.meta.ingress.servicePort", "type": "string"}
      # gateway.meta.ingress.servicePort -- service port to be exposed by ingress
      servicePort: grpc
    # @schema {"name": "gateway.meta.resources", "type": "object", "anchor": "resources"}
    # gateway.meta.resources -- compute resources
    resources:
      # @schema {"name": "gateway.meta.resources.requests", "type": "object"}
      requests:
        cpu: 200m
        memory: 150Mi
      # @schema {"name": "gateway.meta.resources.limits", "type": "object"}
      limits:
        cpu: 2000m
        memory: 700Mi
    # @schema {"name": "gateway.meta.gateway_config", "type": "object"}
    gateway_config:
      # @schema {"name": "gateway.meta.gateway_config.client", "alias": "grpc.client"}
      # gateway.meta.gateway_config.client -- gRPC client for next gateway (overrides defaults.grpc.client)
      client:
        addrs:
          - "vald-gateway-backup.vald.svc.cluster.local"
      # @schema {"name": "gateway.meta.gateway_config.meta", "type": "object"}
      meta:
        # @schema {"name": "gateway.meta.gateway_config.meta.client", "alias": "grpc.client"}
        # gateway.meta.gateway_config.meta.client -- gRPC client for meta (overrides defaults.grpc.client)
        client: {}
        # @schema {"name": "gateway.meta.gateway_config.meta.enable_cache", "type": "boolean"}
        # gateway.meta.gateway_config.meta.enable_cache -- meta cache enabled
        enable_cache: true
        # @schema {"name": "gateway.meta.gateway_config.meta.cache_expiration", "type": "string"}
        # gateway.meta.gateway_config.meta.cache_expiration -- meta cache expire duration
        cache_expiration: "30m"
        # @schema {"name": "gateway.meta.gateway_config.meta.expired_cache_check_duration", "type": "string"}
        # gateway.meta.gateway_config.meta.expired_cache_check_duration -- meta cache expired check duration
        expired_cache_check_duration: "3m"

# @schema {"name": "agent", "type": "object"}
agent:
  # @schema {"name": "agent.enabled", "type": "boolean"}
  # agent.enabled -- agent enabled
  enabled: true
  # @schema {"name": "agent.version", "alias": "version"}
  # agent.version -- version of agent config
  version: v0.0.0
  # @schema {"name": "agent.time_zone", "type": "string"}
  # agent.time_zone -- Time zone
  time_zone: ""
  # @schema {"name": "agent.logging", "alias": "logging"}
  # agent.logging -- logging config (overrides defaults.logging)
  logging: {}
  # @schema {"name": "agent.name", "type": "string"}
  # agent.name -- name of agent deployment
  name: vald-agent-ngt
  # @schema {"name": "agent.kind", "type": "string", "enum": ["StatefulSet", "Deployment", "DaemonSet"]}
  # agent.kind -- deployment kind: Deployment, DaemonSet or StatefulSet
  kind: StatefulSet
  # @schema {"name": "agent.serviceType", "type": "string", "enum": ["ClusterIP", "LoadBalancer", "NodePort"]}
  # agent.serviceType -- service type: ClusterIP, LoadBalancer or NodePort
  serviceType: ClusterIP
  # @schema {"name": "agent.externalTrafficPolicy", "type": "string"}
  # agent.externalTrafficPolicy -- external traffic policy (can be specified when service type is LoadBalancer or NodePort) : Cluster or Local
  externalTrafficPolicy: ""
  # @schema {"name": "agent.progressDeadlineSeconds", "type": "integer"}
  # agent.progressDeadlineSeconds -- progress deadline seconds
  progressDeadlineSeconds: 600
  # @schema {"name": "agent.minReplicas", "type": "integer", "minimum": 0}
  # agent.minReplicas -- minimum number of replicas.
  # if HPA is disabled, the replicas will be set to this value
  minReplicas: 20
  # @schema {"name": "agent.maxReplicas", "type": "integer", "minimum": 0}
  # agent.maxReplicas -- maximum number of replicas.
  # if HPA is disabled, this value will be ignored.
  maxReplicas: 300
  # @schema {"name": "agent.maxUnavailable", "type": "string"}
  # agent.maxUnavailable -- maximum number of unavailable replicas
  maxUnavailable: "1"
  # @schema {"name": "agent.revisionHistoryLimit", "type": "integer", "minimum": 0}
  # agent.revisionHistoryLimit -- number of old history to retain to allow rollback
  revisionHistoryLimit: 2
  # @schema {"name": "agent.terminationGracePeriodSeconds", "type": "integer", "minimum": 0}
  # agent.terminationGracePeriodSeconds -- duration in seconds pod needs to terminate gracefully
  terminationGracePeriodSeconds: 120
  # @schema {"name": "agent.podManagementPolicy", "type": "string", "enum": ["OrderedReady", "Parallel"]}
  # agent.podManagementPolicy -- pod management policy: OrderedReady or Parallel
  podManagementPolicy: OrderedReady
  # @schema {"name": "agent.persistentVolume", "type": "object"}
  persistentVolume:
    # @schema {"name": "agent.persistentVolume.enabled", "type": "boolean"}
    # agent.persistentVolume.enabled -- enables PVC.
    # It is required to enable if agent pod's file store functionality is enabled with non in-memory mode
    enabled: false
    # @schema {"name": "agent.persistentVolume.accessMode", "type": "string"}
    # agent.persistentVolume.accessMode -- agent pod storage accessMode
    accessMode: ReadWriteOnce
    # @schema {"name": "agent.persistentVolume.storageClass", "type": "string"}
    # agent.persistentVolume.storageClass -- storageClass name for agent pod volume
    storageClass: vald-sc
    # @schema {"name": "agent.persistentVolume.size", "type": "string"}
    # agent.persistentVolume.size -- size of agent pod volume
    size: 100Gi
  # @schema {"name": "agent.podPriority", "alias": "podPriority"}
  podPriority:
    # agent.podPriority.enabled -- agent pod PriorityClass enabled
    enabled: true
    # agent.podPriority.value -- agent pod PriorityClass value
    value: 1000000000
  # @schema {"name": "agent.annotations", "type": "object"}
  # agent.annotations -- deployment annotations
  annotations: {}
  # @schema {"name": "agent.podAnnotations", "type": "object"}
  # agent.podAnnotations -- pod annotations
  podAnnotations: {}
  # @schema {"name": "agent.service", "alias": "service"}
  service:
    # agent.service.annotations -- service annotations
    annotations: {}
    # agent.service.labels -- service labels
    labels: {}
  # @schema {"name": "agent.hpa", "alias": "hpa"}
  hpa:
    # agent.hpa.enabled -- HPA enabled
    enabled: false
    # agent.hpa.targetCPUUtilizationPercentage -- HPA CPU utilization percentage
    targetCPUUtilizationPercentage: 80
  # @schema {"name": "agent.image", "alias": "image"}
  image:
    # agent.image.repository -- image repository
    repository: vdaas/vald-agent-ngt
    # agent.image.tag -- image tag (overrides defaults.image.tag)
    tag: ""
    # agent.image.pullPolicy -- image pull policy
    pullPolicy: Always
  # @schema {"name": "agent.rollingUpdate", "type": "object"}
  rollingUpdate:
    # @schema {"name": "agent.rollingUpdate.maxSurge", "type": "string"}
    # agent.rollingUpdate.maxSurge -- max surge of rolling update
    maxSurge: 25%
    # @schema {"name": "agent.rollingUpdate.maxUnavailable", "type": "string"}
    # agent.rollingUpdate.maxUnavailable -- max unavailable of rolling update
    maxUnavailable: 25%
    # @schema {"name": "agent.rollingUpdate.partition", "type": "integer"}
    # agent.rollingUpdate.partition -- StatefulSet partition
    partition: 0
  # @schema {"name": "agent.initContainers", "alias": "initContainers"}
  # agent.initContainers -- init containers
  initContainers: []
  # @schema {"name": "agent.env", "alias": "env"}
  # agent.env -- environment variables
  env: []
  # @schema {"name": "agent.volumeMounts", "alias": "volumeMounts"}
  # agent.volumeMounts -- volume mounts
  volumeMounts: []
  # @schema {"name": "agent.volumes", "alias": "volumes"}
  # agent.volumes -- volumes
  volumes: []
  # @schema {"name": "agent.nodeName", "type": "string"}
  # agent.nodeName -- node name
  nodeName: ""
  # @schema {"name": "agent.nodeSelector", "alias": "nodeSelector"}
  # agent.nodeSelector -- node selector
  nodeSelector: {}
  # @schema {"name": "agent.tolerations", "alias": "tolerations"}
  # agent.tolerations -- tolerations
  tolerations: []
  # @schema {"name": "agent.affinity", "alias": "affinity"}
  affinity:
    nodeAffinity:
      # agent.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution -- node affinity preferred scheduling terms
      preferredDuringSchedulingIgnoredDuringExecution: []
      requiredDuringSchedulingIgnoredDuringExecution:
        # agent.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms -- node affinity required node selectors
        nodeSelectorTerms: []
    podAffinity:
      # agent.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod affinity preferred scheduling terms
      preferredDuringSchedulingIgnoredDuringExecution: []
      # agent.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod affinity required scheduling terms
      requiredDuringSchedulingIgnoredDuringExecution: []
    podAntiAffinity:
      # agent.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity preferred scheduling terms
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            topologyKey: kubernetes.io/hostname
            labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                    - vald-agent-ngt
      # agent.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity required scheduling terms
      requiredDuringSchedulingIgnoredDuringExecution: []
  # @schema {"name": "agent.topologySpreadConstraints", "alias": "topologySpreadConstraints"}
  # agent.topologySpreadConstraints -- topology spread constraints for agent pods
  topologySpreadConstraints: []
  # @schema {"name": "agent.server_config", "alias": "server_config"}
  # agent.server_config -- server config (overrides defaults.server_config)
  server_config:
    servers:
      rest: {}
      grpc: {}
    healths:
      liveness:
        enabled: false
      readiness: {}
    metrics:
      pprof: {}
      prometheus: {}
  # @schema {"name": "agent.observability", "alias": "observability"}
  # agent.observability -- observability config (overrides defaults.observability)
  observability:
    jaeger:
      service_name: vald-agent-ngt
    stackdriver:
      profiler:
        service: vald-agent-ngt
  # @schema {"name": "agent.resources", "alias": "resources"}
  # agent.resources -- compute resources.
  # recommended setting of memory requests = cluster memory * 0.4 / number of agent pods
  resources:
    requests:
      cpu: 300m
      memory: 4Gi
  # @schema {"name": "agent.ngt", "type": "object"}
  ngt:
    # @schema {"name": "agent.ngt.index_path", "type": "string"}
    # agent.ngt.index_path -- path to index data
    index_path: ""
    # @schema {"name": "agent.ngt.auto_index_duration_limit", "type": "string"}
    # agent.ngt.auto_index_duration_limit -- limit duration of automatic indexing
    auto_index_duration_limit: 24h
    # @schema {"name": "agent.ngt.auto_index_check_duration", "type": "string"}
    # agent.ngt.auto_index_check_duration -- check duration of automatic indexing
    auto_index_check_duration: 30m
    # @schema {"name": "agent.ngt.auto_index_length", "type": "integer"}
    # agent.ngt.auto_index_length -- number of cache to trigger automatic indexing
    auto_index_length: 100
    # @schema {"name": "agent.ngt.auto_save_index_duration", "type": "string"}
    # agent.ngt.auto_save_index_duration -- duration of automatic save index
    auto_save_index_duration: 35m
    # @schema {"name": "agent.ngt.auto_create_index_pool_size", "type": "integer"}
    # agent.ngt.auto_create_index_pool_size -- batch process pool size of automatic create index operation
    auto_create_index_pool_size: 10000
    # @schema {"name": "agent.ngt.initial_delay_max_duration", "type": "string"}
    # agent.ngt.initial_delay_max_duration -- maximum duration for initial delay
    initial_delay_max_duration: 3m
    # @schema {"name": "agent.ngt.dimension", "type": "integer", "minimum": 1}
    # agent.ngt.dimension -- vector dimension
    dimension: 4096
    # @schema {"name": "agent.ngt.bulk_insert_chunk_size", "type": "integer"}
    # agent.ngt.bulk_insert_chunk_size -- bulk insert chunk size
    bulk_insert_chunk_size: 10
    # @schema {"name": "agent.ngt.distance_type", "type": "string", "enum": ["l1", "l2", "angle", "hamming", "cos", "cosine", "normalizedangle", "normalizedcosine"]}
    # agent.ngt.distance_type -- distance type.
    # it should be `l1`, `l2`, `angle`, `hamming`, `cosine`, `normalizedangle` or `normalizedcosine`.
    # for further details: https://github.com/yahoojapan/NGT/wiki/Command-Quick-Reference
    distance_type: l2
    # @schema {"name": "agent.ngt.object_type", "type": "string", "enum": ["float", "uint8"]}
    # agent.ngt.object_type -- object type.
    # it should be `float` or `uint8`.
    # for further details: https://github.com/yahoojapan/NGT/wiki/Command-Quick-Reference
    object_type: float
    # @schema {"name": "agent.ngt.creation_edge_size", "type": "integer"}
    # agent.ngt.creation_edge_size -- creation edge size
    creation_edge_size: 20
    # @schema {"name": "agent.ngt.search_edge_size", "type": "integer"}
    # agent.ngt.search_edge_size -- search edge size
    search_edge_size: 10
    # @schema {"name": "agent.ngt.enable_in_memory_mode", "type": "boolean"}
    # agent.ngt.enable_in_memory_mode -- in-memory mode enabled
    enable_in_memory_mode: true
    # @schema {"name": "agent.ngt.default_pool_size", "type": "integer"}
    # agent.ngt.default_pool_size -- default create index batch pool size
    default_pool_size: 10000
    # @schema {"name": "agent.ngt.default_radius", "type": "number"}
    # agent.ngt.default_radius -- default radius used for search
    default_radius: -1.0
    # @schema {"name": "agent.ngt.default_epsilon", "type": "number"}
    # agent.ngt.default_epsilon -- default epsilon used for search
    default_epsilon: 0.01
    # @schema {"name": "agent.ngt.min_load_index_timeout", "type": "string"}
    # agent.ngt.min_load_index_timeout -- minimum duration of load index timeout
    min_load_index_timeout: 3m
    # @schema {"name": "agent.ngt.max_load_index_timeout", "type": "string"}
    # agent.ngt.max_load_index_timeout -- maximum duration of load index timeout
    max_load_index_timeout: 10m
    # @schema {"name": "agent.ngt.load_index_timeout_factor", "type": "string"}
    # agent.ngt.load_index_timeout_factor -- a factor of load index timeout.
    # timeout duration will be calculated by (index count to be loaded) * (factor).
    load_index_timeout_factor: 1ms
  # @schema {"name": "agent.sidecar", "type": "object"}
  sidecar:
    # @schema {"name": "agent.sidecar.enabled", "type": "boolean"}
    # agent.sidecar.enabled -- sidecar enabled
    enabled: false
    # @schema {"name": "agent.sidecar.initContainerEnabled", "type": "boolean"}
    # agent.sidecar.initContainerEnabled -- sidecar on initContainer mode enabled.
    initContainerEnabled: false
    # @schema {"name": "agent.sidecar.version", "alias": "version"}
    # agent.sidecar.version -- version of agent sidecar config
    version: v0.0.0
    # @schema {"name": "agent.sidecar.time_zone", "type": "string"}
    # agent.sidecar.time_zone -- Time zone
    time_zone: ""
    # @schema {"name": "agent.sidecar.logging", "alias": "logging"}
    # agent.sidecar.logging -- logging config (overrides defaults.logging)
    logging: {}
    # @schema {"name": "agent.sidecar.name", "type": "string"}
    # agent.sidecar.name -- name of agent sidecar
    name: vald-agent-sidecar
    # @schema {"name": "agent.sidecar.image", "alias": "image"}
    image:
      # agent.sidecar.image.repository -- image repository
      repository: vdaas/vald-agent-sidecar
      # agent.sidecar.image.tag -- image tag (overrides defaults.image.tag)
      tag: ""
      # agent.sidecar.image.pullPolicy -- image pull policy
      pullPolicy: Always
    # @schema {"name": "agent.sidecar.service", "type": "object"}
    service:
      # @schema {"name": "agent.sidecar.service.enabled", "type": "boolean"}
      # agent.sidecar.service.enabled -- agent sidecar service enabled
      enabled: false
      # @schema {"name": "agent.sidecar.service.annotations", "type": "object"}
      # agent.sidecar.service.annotations -- agent sidecar service annotations
      annotations: {}
      # @schema {"name": "agent.sidecar.service.labels", "type": "object"}
      # agent.sidecar.service.labels -- agent sidecar service labels
      labels: {}
      # @schema {"name": "agent.sidecar.service.type", "type": "string", "enum": ["ClusterIP", "LoadBalancer", "NodePort"]}
      # agent.sidecar.service.type -- service type: ClusterIP, LoadBalancer or NodePort
      type: ClusterIP
      # @schema {"name": "agent.sidecar.service.externalTrafficPolicy", "type": "string"}
      # agent.sidecar.service.externalTrafficPolicy -- external traffic policy (can be specified when service type is LoadBalancer or NodePort) : Cluster or Local
      externalTrafficPolicy: ""
    # @schema {"name": "agent.sidecar.env", "alias": "env"}
    # agent.sidecar.env -- environment variables
    env:
      - name: MY_POD_NAME
        valueFrom:
          fieldRef:
            fieldPath: metadata.name
      - name: AWS_ACCESS_KEY
        valueFrom:
          secretKeyRef:
            name: aws-secret
            key: access-key
      - name: AWS_SECRET_ACCESS_KEY
        valueFrom:
          secretKeyRef:
            name: aws-secret
            key: secret-access-key
    # @schema {"name": "agent.sidecar.server_config", "alias": "server_config"}
    # agent.sidecar.server_config -- server config (overrides defaults.server_config)
    server_config:
      servers:
        rest:
          enabled: false
          port: 18080
          servicePort: 18080
        grpc:
          enabled: false
          port: 18081
          servicePort: 18081
      healths:
        liveness:
          enabled: false
          port: 13000
          servicePort: 13000
        readiness:
          enabled: false
          port: 13001
          servicePort: 13001
      metrics:
        pprof:
          port: 16060
          servicePort: 16060
        prometheus:
          port: 16061
          servicePort: 16061
    # @schema {"name": "agent.sidecar.observability", "alias": "observability"}
    # agent.sidecar.observability -- observability config (overrides defaults.observability)
    observability:
      jaeger:
        service_name: vald-agent-sidecar
      stackdriver:
        profiler:
          service: vald-agent-sidecar
    # @schema {"name": "agent.sidecar.resources", "alias": "resources"}
    # agent.sidecar.resources -- compute resources.
    resources:
      requests:
        cpu: 100m
        memory: 100Mi
    # @schema {"name": "agent.sidecar.config", "type": "object"}
    config:
      # @schema {"name": "agent.sidecar.config.watch_enabled", "type": "boolean"}
      # agent.sidecar.config.watch_enabled -- auto backup triggered by file changes is enabled
      watch_enabled: true
      # @schema {"name": "agent.sidecar.config.auto_backup_enabled", "type": "boolean"}
      # agent.sidecar.config.auto_backup_enabled -- auto backup triggered by timer is enabled
      auto_backup_enabled: true
      # @schema {"name": "agent.sidecar.config.auto_backup_duration", "type": "string"}
      # agent.sidecar.config.auto_backup_duration -- auto backup duration
      auto_backup_duration: 24h
      # @schema {"name": "agent.sidecar.config.post_stop_timeout", "type": "string"}
      # agent.sidecar.config.post_stop_timeout -- timeout for observing file changes during post stop
      post_stop_timeout: 2m
      # @schema {"name": "agent.sidecar.config.filename", "type": "string"}
      # agent.sidecar.config.filename -- backup filename
      filename: _MY_POD_NAME_
      # @schema {"name": "agent.sidecar.config.filename_suffix", "type": "string"}
      # agent.sidecar.config.filename_suffix -- suffix for backup filename
      filename_suffix: ".tar.gz"
      # @schema {"name": "agent.sidecar.config.blob_storage", "type": "object"}
      blob_storage:
        # @schema {"name": "agent.sidecar.config.blob_storage.storage_type", "type": "string", "enum": ["s3"]}
        # agent.sidecar.config.blob_storage.storage_type -- storage type
        storage_type: "s3"
        # @schema {"name": "agent.sidecar.config.blob_storage.bucket", "type": "string"}
        # agent.sidecar.config.blob_storage.bucket -- bucket name
        bucket: ""
        # @schema {"name": "agent.sidecar.config.blob_storage.s3", "type": "object"}
        s3:
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.endpoint", "type": "string"}
          # agent.sidecar.config.blob_storage.s3.endpoint -- s3 endpoint
          endpoint: ""
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.region", "type": "string"}
          # agent.sidecar.config.blob_storage.s3.region -- s3 region
          region: ""
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.access_key", "type": "string"}
          # agent.sidecar.config.blob_storage.s3.access_key -- s3 access key
          access_key: _AWS_ACCESS_KEY_
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.secret_access_key", "type": "string"}
          # agent.sidecar.config.blob_storage.s3.secret_access_key -- s3 secret access key
          secret_access_key: _AWS_SECRET_ACCESS_KEY_
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.token", "type": "string"}
          # agent.sidecar.config.blob_storage.s3.token -- s3 token
          token: ""
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.max_retries", "type": "integer"}
          # agent.sidecar.config.blob_storage.s3.max_retries -- maximum number of retries of s3 client
          max_retries: 3
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.force_path_style", "type": "boolean"}
          # agent.sidecar.config.blob_storage.s3.force_path_style -- use path-style addressing
          force_path_style: false
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.use_accelerate", "type": "boolean"}
          # agent.sidecar.config.blob_storage.s3.use_accelerate -- enable s3 accelerate feature
          use_accelerate: false
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.use_arn_region", "type": "boolean"}
          # agent.sidecar.config.blob_storage.s3.use_arn_region -- s3 service client to use the region specified in the ARN
          use_arn_region: false
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.use_dual_stack", "type": "boolean"}
          # agent.sidecar.config.blob_storage.s3.use_dual_stack -- use dual stack
          use_dual_stack: false
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.enable_ssl", "type": "boolean"}
          # agent.sidecar.config.blob_storage.s3.enable_ssl -- enable ssl for s3 session
          enable_ssl: true
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.enable_param_validation", "type": "boolean"}
          # agent.sidecar.config.blob_storage.s3.enable_param_validation -- enables semantic parameter validation
          enable_param_validation: true
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.enable_100_continue", "type": "boolean"}
          # agent.sidecar.config.blob_storage.s3.enable_100_continue -- enable AWS SDK adding the 'Expect: 100-Continue' header to PUT requests over 2MB of content.
          enable_100_continue: true
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.enable_content_md5_validation", "type": "boolean"}
          # agent.sidecar.config.blob_storage.s3.enable_content_md5_validation -- enable the S3 client to add MD5 checksum to upload API calls.
          enable_content_md5_validation: true
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.enable_endpoint_discovery", "type": "boolean"}
          # agent.sidecar.config.blob_storage.s3.enable_endpoint_discovery -- enable endpoint discovery
          enable_endpoint_discovery: false
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.enable_endpoint_host_prefix", "type": "boolean"}
          # agent.sidecar.config.blob_storage.s3.enable_endpoint_host_prefix -- enable prefixing request endpoint hosts with modeled information
          enable_endpoint_host_prefix: true
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.max_part_size", "type": "string", "pattern": "^[0-9]+(kb|mb|gb)$"}
          # agent.sidecar.config.blob_storage.s3.max_part_size -- s3 multipart upload max part size
          max_part_size: 64mb
          # @schema {"name": "agent.sidecar.config.blob_storage.s3.max_chunk_size", "type": "string", "pattern": "^[0-9]+(kb|mb|gb)$"}
          # agent.sidecar.config.blob_storage.s3.max_chunk_size -- s3 download max chunk size
          max_chunk_size: 64mb
      # @schema {"name": "agent.sidecar.config.compress", "type": "object"}
      compress:
        # @schema {"name": "agent.sidecar.config.compress.compress_algorithm", "type": "string", "enum": ["gob", "gzip", "lz4", "zstd"]}
        # agent.sidecar.config.compress.compress_algorithm -- compression algorithm.
        # must be `gob`, `gzip`, `lz4` or `zstd`
        compress_algorithm: "gzip"
        # @schema {"name": "agent.sidecar.config.compress.compression_level", "type": "integer"}
        # agent.sidecar.config.compress.compression_level -- compression level.
        # value range relies on which algorithm is used.
        # `gob`: level will be ignored.
        # `gzip`: -1 (default compression), 0 (no compression), or 1 (best speed) to 9 (best compression).
        # `lz4`: >= 0, higher is better compression.
        # `zstd`: 1 (fastest) to 22 (best), however implementation relies on klauspost/compress.
        compression_level: -1
      # @schema {"name": "agent.sidecar.config.client", "type": "object"}
      client:
        # @schema {"name": "agent.sidecar.config.client.tcp", "alias": "tcp"}
        tcp:
          dns:
            # agent.sidecar.config.client.tcp.dns.cache_enabled -- HTTP client TCP DNS cache enabled
            cache_enabled: true
            # agent.sidecar.config.client.tcp.dns.refresh_duration -- HTTP client TCP DNS cache refresh duration
            refresh_duration: 1h
            # agent.sidecar.config.client.tcp.dns.refresh_duration -- HTTP client TCP DNS cache expiration
            cache_expiration: 24h
          dialer:
            # agent.sidecar.config.client.tcp.dialer.timeout -- HTTP client TCP dialer connect timeout
            timeout: 5s
            # agent.sidecar.config.client.tcp.dialer.keep_alive -- HTTP client TCP dialer keep alive
            keep_alive: 5m
            # agent.sidecar.config.client.tcp.dialer.dual_stack_enabled -- HTTP client TCP dialer dual stack enabled
            dual_stack_enabled: false
          tls:
            # agent.sidecar.config.client.tcp.tls.enabled -- HTTP client TCP TLS enabled
            enabled: false
            # agent.sidecar.config.client.tcp.tls.cert -- HTTP client TCP TLS cert path
            cert: /path/to/cert
            # agent.sidecar.config.client.tcp.tls.key -- HTTP client TCP TLS key path
            key: /path/to/key
            # agent.sidecar.config.client.tcp.tls.ca -- HTTP client TCP TLS ca path
            ca: /path/to/ca
        # @schema {"name": "agent.sidecar.config.client.transport", "type": "object"}
        transport:
          # @schema {"name": "agent.sidecar.config.client.transport.round_tripper", "type": "object"}
          round_tripper:
            # @schema {"name": "agent.sidecar.config.client.transport.round_tripper.tls_handshake_timeout", "type": "string"}
            # agent.sidecar.config.client.transport.round_tripper.tls_handshake_timeout -- TLS handshake timeout
            tls_handshake_timeout: 5s
            # @schema {"name": "agent.sidecar.config.client.transport.round_tripper.max_idle_conns", "type": "integer"}
            # agent.sidecar.config.client.transport.round_tripper.max_idle_conns -- maximum count of idle connections
            max_idle_conns: 100
            # @schema {"name": "agent.sidecar.config.client.transport.round_tripper.max_idle_conns_per_host", "type": "integer"}
            # agent.sidecar.config.client.transport.round_tripper.max_idle_conns_per_host -- maximum count of idle connections per host
            max_idle_conns_per_host: 10
            # @schema {"name": "agent.sidecar.config.client.transport.round_tripper.max_conns_per_host", "type": "integer"}
            # agent.sidecar.config.client.transport.round_tripper.max_conns_per_host -- maximum count of connections per host
            max_conns_per_host: 10
            # @schema {"name": "agent.sidecar.config.client.transport.round_tripper.idle_conn_timeout", "type": "string"}
            # agent.sidecar.config.client.transport.round_tripper.idle_conn_timeout -- timeout for idle connections
            idle_conn_timeout: 90s
            # @schema {"name": "agent.sidecar.config.client.transport.round_tripper.response_header_timeout", "type": "string"}
            # agent.sidecar.config.client.transport.round_tripper.response_header_timeout -- timeout for response header
            response_header_timeout: 5s
            # @schema {"name": "agent.sidecar.config.client.transport.round_tripper.expect_continue_timeout", "type": "string"}
            # agent.sidecar.config.client.transport.round_tripper.expect_continue_timeout -- expect continue timeout
            expect_continue_timeout: 5s
            # @schema {"name": "agent.sidecar.config.client.transport.round_tripper.max_response_header_size", "type": "integer"}
            # agent.sidecar.config.client.transport.round_tripper.max_response_header_size -- maximum response header size
            max_response_header_size: 0
            # @schema {"name": "agent.sidecar.config.client.transport.round_tripper.write_buffer_size", "type": "integer"}
            # agent.sidecar.config.client.transport.round_tripper.write_buffer_size -- write buffer size
            write_buffer_size: 0
            # @schema {"name": "agent.sidecar.config.client.transport.round_tripper.read_buffer_size", "type": "integer"}
            # agent.sidecar.config.client.transport.round_tripper.read_buffer_size -- read buffer size
            read_buffer_size: 0
            # @schema {"name": "agent.sidecar.config.client.transport.round_tripper.force_attempt_http_2", "type": "boolean"}
            # agent.sidecar.config.client.transport.round_tripper.force_attempt_http_2 -- force attempt HTTP2
            force_attempt_http_2: true
          # @schema {"name": "agent.sidecar.config.client.transport.backoff", "alias": "backoff"}
          backoff:
            # agent.sidecar.config.client.transport.backoff.initial_duration -- backoff initial duration
            initial_duration: 5ms
            # agent.sidecar.config.client.transport.backoff.backoff_time_limit -- backoff time limit
            backoff_time_limit: 5s
            # agent.sidecar.config.client.transport.backoff.maximum_duration -- backoff maximum duration
            maximum_duration: 5s
            # agent.sidecar.config.client.transport.backoff.jitter_limit -- backoff jitter limit
            jitter_limit: 100ms
            # agent.sidecar.config.client.transport.backoff.backoff_factor -- backoff backoff factor
            backoff_factor: 1.1
            # agent.sidecar.config.client.transport.backoff.retry_count -- backoff retry count
            retry_count: 100
            # agent.sidecar.config.client.transport.backoff.enable_error_log -- backoff error log enabled
            enable_error_log: true
      # agent.sidecar.config.restore_backoff_enabled -- restore backoff enabled
      restore_backoff_enabled: false
      # @schema {"name": "agent.sidecar.config.restore_backoff", "alias": "backoff"}
      restore_backoff:
        # agent.sidecar.config.restore_backoff.initial_duration -- restore backoff initial duration
        initial_duration: 1s
        # agent.sidecar.config.restore_backoff.backoff_time_limit -- restore backoff time limit
        backoff_time_limit: 30m
        # agent.sidecar.config.restore_backoff.maximum_duration -- restore backoff maximum duration
        maximum_duration: 1m
        # agent.sidecar.config.restore_backoff.jitter_limit -- restore backoff jitter limit
        jitter_limit: 10s
        # agent.sidecar.config.restore_backoff.backoff_factor -- restore backoff factor
        backoff_factor: 1.2
        # agent.sidecar.config.restore_backoff.retry_count -- restore backoff retry count
        retry_count: 100
        # agent.sidecar.config.restore_backoff.enable_error_log -- restore backoff log enabled
        enable_error_log: true

# @schema {"name": "discoverer", "type": "object"}
discoverer:
  # @schema {"name": "discoverer.enabled", "type": "boolean"}
  # discoverer.enabled -- discoverer enabled
  enabled: true
  # @schema {"name": "discoverer.version", "alias": "version"}
  # discoverer.version -- version of discoverer config
  version: v0.0.0
  # @schema {"name": "discoverer.time_zone", "type": "string"}
  # discoverer.time_zone -- Time zone
  time_zone: ""
  # @schema {"name": "discoverer.logging", "alias": "logging"}
  # discoverer.logging -- logging config (overrides defaults.logging)
  logging: {}
  # @schema {"name": "discoverer.name", "type": "string"}
  # discoverer.name -- name of discoverer deployment
  name: vald-discoverer
  # @schema {"name": "discoverer.kind", "type": "string", "enum": ["Deployment", "DaemonSet"]}
  # discoverer.kind -- deployment kind: Deployment or DaemonSet
  kind: Deployment
  # @schema {"name": "discoverer.serviceType", "type": "string", "enum": ["ClusterIP", "LoadBalancer", "NodePort"]}
  # discoverer.serviceType -- service type: ClusterIP, LoadBalancer or NodePort
  serviceType: ClusterIP
  # @schema {"name": "discoverer.externalTrafficPolicy", "type": "string"}
  # discoverer.externalTrafficPolicy -- external traffic policy (can be specified when service type is LoadBalancer or NodePort) : Cluster or Local
  externalTrafficPolicy: ""
  # @schema {"name": "discoverer.progressDeadlineSeconds", "type": "integer"}
  # discoverer.progressDeadlineSeconds -- progress deadline seconds
  progressDeadlineSeconds: 600
  # @schema {"name": "discoverer.minReplicas", "type": "integer", "minimum": 0}
  # discoverer.minReplicas -- minimum number of replicas.
  # if HPA is disabled, the replicas will be set to this value
  minReplicas: 1
  # @schema {"name": "discoverer.maxReplicas", "type": "integer", "minimum": 0}
  # discoverer.maxReplicas -- maximum number of replicas.
  # if HPA is disabled, this value will be ignored.
  maxReplicas: 2
  # @schema {"name": "discoverer.maxUnavailable", "type": "string"}
  # discoverer.maxUnavailable -- maximum number of unavailable replicas
  maxUnavailable: 50%
  # @schema {"name": "discoverer.revisionHistoryLimit", "type": "integer", "minimum": 0}
  # discoverer.revisionHistoryLimit -- number of old history to retain to allow rollback
  revisionHistoryLimit: 2
  # @schema {"name": "discoverer.terminationGracePeriodSeconds", "type": "integer", "minimum": 0}
  # discoverer.terminationGracePeriodSeconds -- duration in seconds pod needs to terminate gracefully
  terminationGracePeriodSeconds: 30
  # @schema {"name": "discoverer.podPriority", "alias": "podPriority"}
  podPriority:
    # discoverer.podPriority.enabled -- discoverer pod PriorityClass enabled
    enabled: true
    # discoverer.podPriority.value -- discoverer pod PriorityClass value
    value: 1000000
  # @schema {"name": "discoverer.annotations", "type": "object"}
  # discoverer.annotations -- deployment annotations
  annotations: {}
  # @schema {"name": "discoverer.podAnnotations", "type": "object"}
  # discoverer.podAnnotations -- pod annotations
  podAnnotations: {}
  # @schema {"name": "discoverer.hpa", "alias": "hpa"}
  hpa:
    # discoverer.hpa.enabled -- HPA enabled
    enabled: false
    # discoverer.hpa.targetCPUUtilizationPercentage -- HPA CPU utilization percentage
    targetCPUUtilizationPercentage: 80
  # @schema {"name": "discoverer.service", "alias": "service"}
  service:
    # discoverer.service.annotations -- service annotations
    annotations: {}
    # discoverer.service.labels -- service labels
    labels: {}
  # @schema {"name": "discoverer.image", "alias": "image"}
  image:
    # discoverer.image.repository -- image repository
    repository: vdaas/vald-discoverer-k8s
    # discoverer.image.tag -- image tag (overrides defaults.image.tag)
    tag: ""
    # discoverer.image.pullPolicy -- image pull policy
    pullPolicy: Always
  # @schema {"name": "discoverer.rollingUpdate", "alias": "rollingUpdate"}
  rollingUpdate:
    # discoverer.rollingUpdate.maxSurge -- max surge of rolling update
    maxSurge: 25%
    # discoverer.rollingUpdate.maxUnavailable -- max unavailable of rolling update
    maxUnavailable: 25%
  # @schema {"name": "discoverer.initContainers", "alias": "initContainers"}
  # discoverer.initContainers -- init containers
  initContainers: []
  # @schema {"name": "discoverer.env", "alias": "env"}
  # discoverer.env -- environment variables
  env:
    - name: MY_POD_NAMESPACE
      valueFrom:
        fieldRef:
          fieldPath: metadata.namespace
  # @schema {"name": "discoverer.volumeMounts", "alias": "volumeMounts"}
  # discoverer.volumeMounts -- volume mounts
  volumeMounts: []
  # @schema {"name": "discoverer.volumes", "alias": "volumes"}
  # discoverer.volumes -- volumes
  volumes: []
  # @schema {"name": "discoverer.nodeName", "type": "string"}
  # discoverer.nodeName -- node name
  nodeName: ""
  # @schema {"name": "discoverer.nodeSelector", "alias": "nodeSelector"}
  # discoverer.nodeSelector -- node selector
  nodeSelector: {}
  # @schema {"name": "discoverer.tolerations", "alias": "tolerations"}
  # discoverer.tolerations -- tolerations
  tolerations: []
  # @schema {"name": "discoverer.affinity", "alias": "affinity"}
  affinity:
    nodeAffinity:
      # discoverer.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution -- node affinity preferred scheduling terms
      preferredDuringSchedulingIgnoredDuringExecution: []
      requiredDuringSchedulingIgnoredDuringExecution:
        # discoverer.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms -- node affinity required node selectors
        nodeSelectorTerms: []
    podAffinity:
      # discoverer.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod affinity preferred scheduling terms
      preferredDuringSchedulingIgnoredDuringExecution: []
      # discoverer.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod affinity required scheduling terms
      requiredDuringSchedulingIgnoredDuringExecution: []
    podAntiAffinity:
      # discoverer.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity preferred scheduling terms
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            topologyKey: kubernetes.io/hostname
            labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                    - vald-discoverer
      # discoverer.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity required scheduling terms
      requiredDuringSchedulingIgnoredDuringExecution: []
  # @schema {"name": "discoverer.topologySpreadConstraints", "alias": "topologySpreadConstraints"}
  # discoverer.topologySpreadConstraints -- topology spread constraints of discoverer pods
  topologySpreadConstraints: []
  # @schema {"name": "discoverer.server_config", "alias": "server_config"}
  # discoverer.server_config -- server config (overrides defaults.server_config)
  server_config:
    servers:
      rest: {}
      grpc: {}
    healths:
      liveness: {}
      readiness: {}
    metrics:
      pprof: {}
      prometheus: {}
  # @schema {"name": "discoverer.observability", "alias": "observability"}
  # discoverer.observability -- observability config (overrides defaults.observability)
  observability:
    jaeger:
      service_name: vald-discoverer
    stackdriver:
      profiler:
        service: vald-discoverer
  # @schema {"name": "discoverer.resources", "alias": "resources"}
  # discoverer.resources -- compute resources
  resources:
    requests:
      cpu: 200m
      memory: 65Mi
    limits:
      cpu: 600m
      memory: 200Mi
  # @schema {"name": "discoverer.discoverer", "type": "object"}
  discoverer:
    # @schema {"name": "discoverer.discoverer.name", "type": "string"}
    # discoverer.discoverer.name -- name to discovery
    name: ""
    # @schema {"name": "discoverer.discoverer.namespace", "type": "string"}
    # discoverer.discoverer.namespace -- namespace to discovery
    namespace: _MY_POD_NAMESPACE_
    # @schema {"name": "discoverer.discoverer.discovery_duration", "type": "string"}
    # discoverer.discoverer.discovery_duration -- duration to discovery
    discovery_duration: 3s
  # @schema {"name": "discoverer.clusterRole", "type": "object"}
  clusterRole:
    # @schema {"name": "discoverer.clusterRole.enabled", "type": "boolean"}
    # discoverer.clusterRole.enabled -- creates clusterRole resource
    enabled: true
    # @schema {"name": "discoverer.clusterRole.name", "type": "string"}
    # discoverer.clusterRole.name -- name of clusterRole
    name: discoverer
  # @schema {"name": "discoverer.clusterRoleBinding", "type": "object"}
  clusterRoleBinding:
    # @schema {"name": "discoverer.clusterRoleBinding.enabled", "type": "boolean"}
    # discoverer.clusterRoleBinding.enabled -- creates clusterRoleBinding resource
    enabled: true
    # @schema {"name": "discoverer.clusterRoleBinding.name", "type": "string"}
    # discoverer.clusterRoleBinding.name -- name of clusterRoleBinding
    name: discoverer
  # @schema {"name": "discoverer.serviceAccount", "type": "object"}
  serviceAccount:
    # @schema {"name": "discoverer.serviceAccount.enabled", "type": "boolean"}
    # discoverer.serviceAccount.enabled -- creates service account
    enabled: true
    # @schema {"name": "discoverer.serviceAccount.name", "type": "string"}
    # discoverer.serviceAccount.name -- name of service account
    name: vald

# @schema {"name": "manager", "type": "object"}
manager:

  # @schema {"name": "manager.compressor", "type": "object"}
  compressor:
    # @schema {"name": "manager.compressor.enabled", "type": "boolean"}
    # manager.compressor.enabled -- compressor enabled
    enabled: true
    # @schema {"name": "manager.compressor.version", "alias": "version"}
    # manager.compressor.version -- version of compressor config
    version: v0.0.0
    # @schema {"name": "manager.compressor.time_zone", "type": "string"}
    # manager.compressor.time_zone -- Time zone
    time_zone: ""
    # @schema {"name": "manager.compressor.logging", "alias": "logging"}
    # manager.compressor.logging -- logging config (overrides defaults.logging)
    logging: {}
    # @schema {"name": "manager.compressor.name", "type": "string"}
    # manager.compressor.name -- name of compressor deployment
    name: vald-manager-compressor
    # @schema {"name": "manager.compressor.kind", "type": "string", "enum": ["Deployment", "DaemonSet"]}
    # manager.compressor.kind -- deployment kind: Deployment or DaemonSet
    kind: Deployment
    # @schema {"name": "manager.compressor.serviceType", "type": "string", "enum": ["ClusterIP", "LoadBalancer", "NodePort"]}
    # manager.compressor.serviceType -- service type: ClusterIP, LoadBalancer or NodePort
    serviceType: ClusterIP
    # @schema {"name": "manager.compressor.externalTrafficPolicy", "type": "string"}
    # manager.compressor.externalTrafficPolicy -- external traffic policy (can be specified when service type is LoadBalancer or NodePort) : Cluster or Local
    externalTrafficPolicy: ""
    # @schema {"name": "manager.compressor.progressDeadlineSeconds", "type": "integer"}
    # manager.compressor.progressDeadlineSeconds -- progress deadline seconds
    progressDeadlineSeconds: 600
    # @schema {"name": "manager.compressor.minReplicas", "type": "integer", "minimum": 0}
    # manager.compressor.minReplicas -- minimum number of replicas.
    # if HPA is disabled, the replicas will be set to this value
    minReplicas: 3
    # @schema {"name": "manager.compressor.maxReplicas", "type": "integer", "minimum": 0}
    # manager.compressor.maxReplicas -- maximum number of replicas.
    # if HPA is disabled, this value will be ignored.
    maxReplicas: 15
    # @schema {"name": "manager.compressor.maxUnavailable", "type": "string"}
    # manager.compressor.maxUnavailable -- maximum number of unavailable replicas
    maxUnavailable: "1"
    # @schema {"name": "manager.compressor.revisionHistoryLimit", "type": "integer", "minimum": 0}
    # manager.compressor.revisionHistoryLimit -- number of old history to retain to allow rollback
    revisionHistoryLimit: 2
    # @schema {"name": "manager.compressor.terminationGracePeriodSeconds", "type": "integer", "minimum": 0}
    # manager.compressor.terminationGracePeriodSeconds -- duration in seconds pod needs to terminate gracefully
    terminationGracePeriodSeconds: 120
    # @schema {"name": "manager.compressor.podPriority", "alias": "podPriority"}
    podPriority:
      # manager.compressor.podPriority.enabled -- compressor pod PriorityClass enabled
      enabled: true
      # manager.compressor.podPriority.value -- compressor pod PriorityClass value
      value: 100000000
    # @schema {"name": "manager.compressor.annotations", "type": "object"}
    # manager.compressor.annotations -- deployment annotations
    annotations: {}
    # @schema {"name": "manager.compressor.podAnnotations", "type": "object"}
    # manager.compressor.podAnnotations -- pod annotations
    podAnnotations: {}
    # @schema {"name": "manager.compressor.service", "alias": "service"}
    service:
      # manager.compressor.service.annotations -- service annotations
      annotations: {}
      # manager.compressor.service.labels -- service labels
      labels: {}
    # @schema {"name": "manager.compressor.hpa", "alias": "hpa"}
    hpa:
      # manager.compressor.hpa.enabled -- HPA enabled
      enabled: true
      # manager.compressor.hpa.targetCPUUtilizationPercentage -- HPA CPU utilization percentage
      targetCPUUtilizationPercentage: 80
    # @schema {"name": "manager.compressor.image", "alias": "image"}
    image:
      # manager.compressor.image.repository -- image repository
      repository: vdaas/vald-manager-compressor
      # manager.compressor.image.tag -- image tag (overrides defaults.image.tag)
      tag: ""
      # manager.compressor.image.pullPolicy -- image pull policy
      pullPolicy: Always
    # @schema {"name": "manager.compressor.rollingUpdate", "alias": "rollingUpdate"}
    rollingUpdate:
      # manager.compressor.rollingUpdate.maxSurge -- max surge of rolling update
      maxSurge: 25%
      # manager.compressor.rollingUpdate.maxUnavailable -- max unavailable of rolling update
      maxUnavailable: 25%
    # @schema {"name": "manager.compressor.initContainers", "alias": "initContainers"}
    # manager.compressor.initContainers -- init containers
    initContainers:
      - type: wait-for
        name: wait-for-manager-backup
        target: manager-backup
        image: busybox
        sleepDuration: 2
    # @schema {"name": "manager.compressor.env", "alias": "env"}
    # manager.compressor.env -- environment variables
    env:
      - name: MY_POD_IP
        valueFrom:
          fieldRef:
            fieldPath: status.podIP
    # @schema {"name": "manager.compressor.volumeMounts", "alias": "volumeMounts"}
    # manager.compressor.volumeMounts -- volume mounts
    volumeMounts: []
    # @schema {"name": "manager.compressor.volumes", "alias": "volumes"}
    # manager.compressor.volumes -- volumes
    volumes: []
    # @schema {"name": "manager.compressor.nodeName", "type": "string"}
    # manager.compressor.nodeName -- node name
    nodeName: ""
    # @schema {"name": "manager.compressor.nodeSelector", "alias": "nodeSelector"}
    # manager.compressor.nodeSelector -- node selector
    nodeSelector: {}
    # @schema {"name": "manager.compressor.tolerations", "alias": "tolerations"}
    # manager.compressor.tolerations -- tolerations
    tolerations: []
    # @schema {"name": "manager.compressor.affinity", "alias": "affinity"}
    affinity:
      nodeAffinity:
        # manager.compressor.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution -- node affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        requiredDuringSchedulingIgnoredDuringExecution:
          # manager.compressor.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms -- node affinity required node selectors
          nodeSelectorTerms: []
      podAffinity:
        # manager.compressor.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # manager.compressor.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
      podAntiAffinity:
        # manager.compressor.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # manager.compressor.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
    # @schema {"name": "manager.compressor.topologySpreadConstraints", "alias": "topologySpreadConstraints"}
    # manager.compressor.topologySpreadConstraints -- topology spread constraints of compressor pods
    topologySpreadConstraints: []
    # @schema {"name": "manager.compressor.server_config", "alias": "server_config"}
    # manager.compressor.server_config -- server config (overrides defaults.server_config)
    server_config:
      servers:
        rest: {}
        grpc: {}
      healths:
        liveness:
          server:
            http:
              shutdown_duration: 2m
        readiness: {}
      metrics:
        pprof: {}
        prometheus: {}
    # @schema {"name": "manager.compressor.observability", "alias": "observability"}
    # manager.compressor.observability -- observability config (overrides defaults.observability)
    observability:
      jaeger:
        service_name: vald-manager-compressor
      stackdriver:
        profiler:
          service: vald-manager-compressor
    # @schema {"name": "manager.compressor.resources", "alias": "resources"}
    # manager.compressor.resources -- compute resources
    resources:
      requests:
        cpu: 300m
        memory: 50Mi
      limits:
        cpu: 800m
        memory: 500Mi
    # @schema {"name": "manager.compressor.backup", "type": "object"}
    backup:
      # @schema {"name": "manager.compressor.backup.client", "alias": "grpc.client"}
      # manager.compressor.backup.client -- grpc client for backup (overrides defaults.grpc.client)
      client: {}
    # @schema {"name": "manager.compressor.compress", "type": "object"}
    compress:
      # @schema {"name": "manager.compressor.compress.compress_algorithm", "type": "string", "enum": ["gob", "gzip", "lz4", "zstd"]}
      # manager.compressor.compress.compress_algorithm -- compression algorithm.
      # must be `gob`, `gzip`, `lz4` or `zstd`
      compress_algorithm: zstd
      # @schema {"name": "manager.compressor.compress.compression_level", "type": "integer"}
      # manager.compressor.compress.compression_level -- compression level.
      # value range relies on which algorithm is used.
      # `gob`: level will be ignored.
      # `gzip`: -1 (default compression), 0 (no compression), or 1 (best speed) to 9 (best compression).
      # `lz4`: >= 0, higher is better compression.
      # `zstd`: 1 (fastest) to 22 (best), however implementation relies on klauspost/compress.
      compression_level: 3
      # @schema {"name": "manager.compressor.compress.concurrent_limit", "type": "integer"}
      # manager.compressor.compress.concurrent_limit -- concurrency limit for compress/decompress processes
      concurrent_limit: 10
      # @schema {"name": "manager.compressor.compress.queue_check_duration", "type": "string"}
      # manager.compressor.compress.queue_check_duration represents duration of queue daemon block
      queue_check_duration: 200ms
    # @schema {"name": "manager.compressor.registerer", "type": "object"}
    registerer:
      # @schema {"name": "manager.compressor.registerer.concurrent_limit", "type": "integer"}
      # manager.compressor.registerer.concurrent_limit -- concurrency limit for registering vector processes
      concurrent_limit: 10
      # @schema {"name": "manager.compressor.registerer.queue_check_duration", "type": "string"}
      # manager.compressor.registerer.queue_check_duration represents duration of queue daemon block
      queue_check_duration: 200ms
      # @schema {"name": "manager.compressor.registerer.compressor", "type": "object"}
      compressor:
        # @schema {"name": "manager.compressor.registerer.compressor.client", "alias": "grpc.client"}
        # manager.compressor.registerer.compressor.client -- gRPC client for compressor (overrides defaults.grpc.client)
        client: {}

  # @schema {"name": "manager.backup", "type": "object"}
  backup:
    # @schema {"name": "manager.backup.enabled", "type": "boolean"}
    # manager.backup.enabled -- backup manager enabled
    enabled: true
    # @schema {"name": "manager.backup.version", "alias": "version"}
    # manager.backup.version -- version of backup manager config
    version: v0.0.0
    # @schema {"name": "manager.backup.time_zone", "type": "string"}
    # manager.backup.time_zone -- Time zone
    time_zone: ""
    # @schema {"name": "manager.backup.logging", "alias": "logging"}
    # manager.backup.logging -- logging config (overrides defaults.logging)
    logging: {}
    # @schema {"name": "manager.backup.name", "type": "string"}
    # manager.backup.name -- name of backup manager deployment
    name: vald-manager-backup
    # @schema {"name": "manager.backup.kind", "type": "string", "enum": ["Deployment", "DaemonSet"]}
    # manager.backup.kind -- deployment kind: Deployment or DaemonSet
    kind: Deployment
    # @schema {"name": "manager.backup.serviceType", "type": "string", "enum": ["ClusterIP", "LoadBalancer", "NodePort"]}
    # manager.backup.serviceType -- service type: ClusterIP, LoadBalancer or NodePort
    serviceType: ClusterIP
    # @schema {"name": "manager.backup.externalTrafficPolicy", "type": "string"}
    # manager.backup.externalTrafficPolicy -- external traffic policy (can be specified when service type is LoadBalancer or NodePort) : Cluster or Local
    externalTrafficPolicy: ""
    # @schema {"name": "manager.backup.progressDeadlineSeconds", "type": "integer"}
    # manager.backup.progressDeadlineSeconds -- progress deadline seconds
    progressDeadlineSeconds: 600
    # @schema {"name": "manager.backup.minReplicas", "type": "integer", "minimum": 0}
    # manager.backup.minReplicas -- minimum number of replicas.
    # if HPA is disabled, the replicas will be set to this value
    minReplicas: 3
    # @schema {"name": "manager.backup.maxReplicas", "type": "integer", "minimum": 0}
    # manager.backup.maxReplicas -- maximum number of replicas.
    # if HPA is disabled, this value will be ignored.
    maxReplicas: 15
    # @schema {"name": "manager.backup.maxUnavailable", "type": "string"}
    # manager.backup.maxUnavailable -- maximum number of unavailable replicas
    maxUnavailable: 50%
    # @schema {"name": "manager.backup.revisionHistoryLimit", "type": "integer", "minimum": 0}
    # manager.backup.revisionHistoryLimit -- number of old history to retain to allow rollback
    revisionHistoryLimit: 2
    # @schema {"name": "manager.backup.terminationGracePeriodSeconds", "type": "integer", "minimum": 0}
    # manager.backup.terminationGracePeriodSeconds -- duration in seconds pod needs to terminate gracefully
    terminationGracePeriodSeconds: 30
    # @schema {"name": "manager.backup.podPriority", "alias": "podPriority"}
    podPriority:
      # manager.backup.podPriority.enabled -- backup manager pod PriorityClass enabled
      enabled: true
      # manager.backup.podPriority.value -- backup manager pod PriorityClass value
      value: 1000000
    # @schema {"name": "manager.backup.annotations", "type": "object"}
    # manager.backup.annotations -- deployment annotations
    annotations: {}
    # @schema {"name": "manager.backup.podAnnotations", "type": "object"}
    # manager.backup.podAnnotations -- pod annotations
    podAnnotations: {}
    # @schema {"name": "manager.backup.service", "alias": "service"}
    service:
      # manager.backup.service.annotations -- service annotations
      annotations: {}
      # manager.backup.service.labels -- service labels
      labels: {}
    # @schema {"name": "manager.backup.hpa", "alias": "hpa"}
    hpa:
      # manager.backup.hpa.enabled -- HPA enabled
      enabled: true
      # manager.backup.hpa.targetCPUUtilizationPercentage -- HPA CPU utilization percentage
      targetCPUUtilizationPercentage: 80
    # @schema {"name": "manager.backup.image", "alias": "image"}
    image:
      # manager.backup.image.repository -- image repository
      repository: vdaas/vald-manager-backup-mysql
      # repository: vdaas/vald-manager-backup-cassandra
      # manager.backup.image.tag -- image tag (overrides defaults.image.tag)
      tag: ""
      # manager.backup.image.pullPolicy -- image pull policy
      pullPolicy: Always
    # @schema {"name": "manager.backup.rollingUpdate", "alias": "rollingUpdate"}
    rollingUpdate:
      # manager.backup.rollingUpdate.maxSurge -- max surge of rolling update
      maxSurge: 25%
      # manager.backup.rollingUpdate.maxUnavailable -- max unavailable of rolling update
      maxUnavailable: 25%
    # @schema {"name": "manager.backup.initContainers", "alias": "initContainers"}
    # manager.backup.initContainers -- init containers
    initContainers:
      - type: wait-for-mysql
        name: wait-for-mysql
        image: mysql:latest
        mysql:
          hosts:
            - mysql.default.svc.cluster.local
          options:
            - "-uroot"
            - "-p${MYSQL_PASSWORD}"
        sleepDuration: 2
        env:
          - name: MYSQL_PASSWORD
            valueFrom:
              secretKeyRef:
                name: mysql-secret
                key: password
      # - type: wait-for-cassandra
      #   name: wait-for-cassandra
      #   image: cassandra:latest
      #   cassandra:
      #     hosts:
      #       - cassandra-0.cassandra.default.svc.cluster.local
      #       - cassandra-1.cassandra.default.svc.cluster.local
      #       - cassandra-2.cassandra.default.svc.cluster.local
      #     options:
      #       - "-uroot"
      #       - "-p${CASSANDRA_PASSWORD}"
      #   sleepDuration: 2
      #   env:
      #   - name: CASSANDRA_PASSWORD
      #     valueFrom:
      #       secretKeyRef:
      #         name: cassandra-secret
      #         key: password
      # - type: wait-for-cassandra
      #   name: wait-for-scylla
      #   image: cassandra:latest
      #   cassandra:
      #     hosts:
      #       - scylla-0.scylla.default.svc.cluster.local
      #       - scylla-1.scylla.default.svc.cluster.local
      #       - scylla-2.scylla.default.svc.cluster.local
      #   sleepDuration: 2
    # @schema {"name": "manager.backup.env", "alias": "env"}
    # manager.backup.env -- environment variables
    env:
      - name: MYSQL_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysql-secret
            key: password
      # - name: CASSANDRA_PASSWORD
      #   valueFrom:
      #     secretKeyRef:
      #       name: cassandra-secret
      #       key: password
    # @schema {"name": "manager.backup.volumeMounts", "alias": "volumeMounts"}
    # manager.backup.volumeMounts -- volume mounts
    volumeMounts: []
    # @schema {"name": "manager.backup.volumes", "alias": "volumes"}
    # manager.backup.volumes -- volumes
    volumes: []
    # @schema {"name": "manager.backup.nodeName", "type": "string"}
    # manager.backup.nodeName -- node name
    nodeName: ""
    # @schema {"name": "manager.backup.nodeSelector", "alias": "nodeSelector"}
    # manager.backup.nodeSelector -- node selector
    nodeSelector: {}
    # @schema {"name": "manager.backup.tolerations", "alias": "tolerations"}
    # manager.backup.tolerations -- tolerations
    tolerations: []
    # @schema {"name": "manager.backup.affinity", "alias": "affinity"}
    affinity:
      nodeAffinity:
        # manager.backup.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution -- node affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        requiredDuringSchedulingIgnoredDuringExecution:
          # manager.backup.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms -- node affinity required node selectors
          nodeSelectorTerms: []
      podAffinity:
        # manager.backup.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # manager.backup.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
      podAntiAffinity:
        # manager.backup.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # manager.backup.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
    # @schema {"name": "manager.backup.topologySpreadConstraints", "alias": "topologySpreadConstraints"}
    # manager.backup.topologySpreadConstraints -- topology spread constraints of backup manager pods
    topologySpreadConstraints: []
    # @schema {"name": "manager.backup.server_config", "alias": "server_config"}
    # manager.backup.server_config -- server config (overrides defaults.server_config)
    server_config:
      servers:
        rest: {}
        grpc: {}
      healths:
        liveness: {}
        readiness: {}
      metrics:
        pprof: {}
        prometheus: {}
    # @schema {"name": "manager.backup.observability", "alias": "observability"}
    # manager.backup.observability -- observability config (overrides defaults.observability)
    observability:
      jaeger:
        service_name: vald-manager-backup
      stackdriver:
        profiler:
          service: vald-manager-backup
    # @schema {"name": "manager.backup.resources", "alias": "resources"}
    # manager.backup.resources -- compute resources
    resources:
      requests:
        cpu: 100m
        memory: 50Mi
      limits:
        cpu: 500m
        memory: 150Mi
    # @schema {"name": "manager.backup.mysql", "type": "object"}
    mysql:
      # @schema {"name": "manager.backup.mysql.enabled", "type": "boolean"}
      # manager.backup.mysql.enabled -- mysql config enabled
      enabled: true
      # @schema {"name": "manager.backup.mysql.config", "type": "object"}
      config:
        # @schema {"name": "manager.backup.mysql.config.db", "type": "string", "enum": ["mysql", "postgres", "sqlite3"]}
        # manager.backup.mysql.config.db -- mysql db: mysql, postgres or sqlite3
        db: mysql
        # @schema {"name": "manager.backup.mysql.config.host", "type": "string"}
        # manager.backup.mysql.config.host -- mysql hostname
        host: mysql.default.svc.cluster.local
        # @schema {"name": "manager.backup.mysql.config.port", "type": "integer"}
        # manager.backup.mysql.config.port -- mysql port
        port: 3306
        # @schema {"name": "manager.backup.mysql.config.user", "type": "string"}
        # manager.backup.mysql.config.user -- mysql username
        user: root
        # @schema {"name": "manager.backup.mysql.config.pass", "type": "string"}
        # manager.backup.mysql.config.pass -- mysql password
        pass: _MYSQL_PASSWORD_
        # @schema {"name": "manager.backup.mysql.config.name", "type": "string"}
        # manager.backup.mysql.config.name -- mysql db name
        name: vald
        # @schema {"name": "manager.backup.mysql.config.conn_max_life_time", "type": "string"}
        # manager.backup.mysql.config.conn_max_life_time -- connection maximum life time
        conn_max_life_time: 30s
        # @schema {"name": "manager.backup.mysql.config.max_open_conns", "type": "integer"}
        # manager.backup.mysql.config.max_open_conns -- maximum number of open connections
        max_open_conns: 100
        # @schema {"name": "manager.backup.mysql.config.max_idle_conns", "type": "integer"}
        # manager.backup.mysql.config.max_idle_conns -- maximum number of idle connections
        max_idle_conns: 100
        # @schema {"name": "manager.backup.mysql.config.tls", "alias": "tls"}
        tls:
          # manager.backup.mysql.config.tls.enabled -- TLS enabled
          enabled: false
          # manager.backup.mysql.config.tls.cert -- path to TLS cert
          cert: /path/to/cert
          # manager.backup.mysql.config.tls.key -- path to TLS key
          key: /path/to/key
          # manager.backup.mysql.config.tls.ca -- path to TLS ca
          ca: /path/to/ca
        # @schema {"name": "manager.backup.mysql.config.tls", "alias": "tcp"}
        tcp:
          dns:
            # manager.backup.mysql.config.tcp.dns.cache_enabled -- TCP DNS cache enabled
            cache_enabled: true
            # manager.backup.mysql.config.tcp.dns.refresh_duration -- TCP DNS cache refresh duration
            refresh_duration: 1h
            # manager.backup.mysql.config.tcp.dns.cache_expiration -- TCP DNS cache expiration
            cache_expiration: 24h
          dialer:
            # manager.backup.mysql.config.tcp.dialer.timeout -- TCP dialer timeout
            timeout: 5s
            # manager.backup.mysql.config.tcp.dialer.keep_alive -- TCP dialer keep alive
            keep_alive: 5m
            # manager.backup.mysql.config.tcp.dialer.dual_stack_enabled -- TCP dialer dual stack enabled
            dual_stack_enabled: false
          tls:
            # manager.backup.mysql.config.tcp.tls.enabled -- TCP TLS enabled
            enabled: false
            # manager.backup.mysql.config.tcp.tls.cert -- path to TCP TLS cert
            cert: /path/to/cert
            # manager.backup.mysql.config.tcp.tls.key -- path to TCP TLS key
            key: /path/to/key
            # manager.backup.mysql.config.tcp.tls.ca -- path to TCP TLS ca
            ca: /path/to/ca
    # @schema {"name": "manager.backup.cassandra", "type": "object", "anchor": "cassandra"}
    cassandra:
      # @schema {"name": "manager.backup.cassandra.enabled", "type": "boolean"}
      # manager.backup.cassandra.enabled -- cassandra config enabled
      enabled: false
      # @schema {"name": "manager.backup.cassandra.config", "type": "object"}
      config:
        # @schema {"name": "manager.backup.cassandra.config.hosts", "type": "array", "items": {"type": "string"}}
        # manager.backup.cassandra.config.hosts -- cassandra hosts
        hosts:
          - cassandra-0.cassandra.default.svc.cluster.local
          - cassandra-1.cassandra.default.svc.cluster.local
          - cassandra-2.cassandra.default.svc.cluster.local
          # - scylla-0.scylla.default.svc.cluster.local
          # - scylla-1.scylla.default.svc.cluster.local
          # - scylla-2.scylla.default.svc.cluster.local
        # @schema {"name": "manager.backup.cassandra.config.cql_version", "type": "string"}
        # manager.backup.cassandra.config.cql_version -- cassandra CQL version
        cql_version: 3.0.0
        # @schema {"name": "manager.backup.cassandra.config.proto_version", "type": "integer"}
        # manager.backup.cassandra.config.proto_version -- cassandra proto version
        proto_version: 0
        # @schema {"name": "manager.backup.cassandra.config.timeout", "type": "string"}
        # manager.backup.cassandra.config.timeout -- timeout
        timeout: 600ms
        # @schema {"name": "manager.backup.cassandra.config.connect_timeout", "type": "string"}
        # manager.backup.cassandra.config.connect_timeout -- connect timeout
        connect_timeout: 3s
        # @schema {"name": "manager.backup.cassandra.config.port", "type": "integer"}
        # manager.backup.cassandra.config.port -- cassandra port
        port: 9042
        # @schema {"name": "manager.backup.cassandra.config.keyspace", "type": "string"}
        # manager.backup.cassandra.config.keyspace -- cassandra keyspace
        keyspace: vald
        # @schema {"name": "manager.backup.cassandra.config.num_conns", "type": "integer"}
        # manager.backup.cassandra.config.num_conns -- number of connections per hosts
        num_conns: 2
        # @schema {"name": "manager.backup.cassandra.config.consistency", "type": "string", "enum": ["any", "one", "two", "three", "all", "quorum", "localquorum", "eachquorum", "localone"]}
        # manager.backup.cassandra.config.consistency -- consistency type
        consistency: quorum
        # @schema {"name": "manager.backup.cassandra.config.serial_consistency", "type": "string", "enum": ["localserial", "serial"]}
        # manager.backup.cassandra.config.serial_consistency -- read consistency type
        serial_consistency: localserial
        # @schema {"name": "manager.backup.cassandra.config.username", "type": "string"}
        # manager.backup.cassandra.config.username -- cassandra username
        username: root
        # @schema {"name": "manager.backup.cassandra.config.password", "type": "string"}
        # manager.backup.cassandra.config.password -- cassandra password
        password: _CASSANDRA_PASSWORD_
        # @schema {"name": "manager.backup.cassandra.config.retry_policy", "type": "object"}
        retry_policy:
          # @schema {"name": "manager.backup.cassandra.config.retry_policy.num_retries", "type": "integer"}
          # manager.backup.cassandra.config.retry_policy.num_retries -- number of retries
          num_retries: 3
          # @schema {"name": "manager.backup.cassandra.config.retry_policy.min_duration", "type": "string"}
          # manager.backup.cassandra.config.retry_policy.min_duration -- minimum duration to retry
          min_duration: 10ms
          # @schema {"name": "manager.backup.cassandra.config.retry_policy.max_duration", "type": "string"}
          # manager.backup.cassandra.config.retry_policy.max_duration -- maximum duration to retry
          max_duration: 1s
        # @schema {"name": "manager.backup.cassandra.config.reconnection_policy", "type": "object"}
        reconnection_policy:
          # @schema {"name": "manager.backup.cassandra.config.reconnection_policy.max_retries", "type": "integer"}
          # manager.backup.cassandra.config.reconnection_policy.max_retries -- maximum number of retries to reconnect
          max_retries: 3
          # @schema {"name": "manager.backup.cassandra.config.reconnection_policy.initial_interval", "type": "string"}
          # manager.backup.cassandra.config.reconnection_policy.initial_interval -- initial interval to reconnect
          initial_interval: 100ms
        # @schema {"name": "manager.backup.cassandra.config.socket_keepalive", "type": "string"}
        # manager.backup.cassandra.config.socket_keepalive -- socket keep alive time
        socket_keepalive: 0s
        # @schema {"name": "manager.backup.cassandra.config.max_prepared_stmts", "type": "integer"}
        # manager.backup.cassandra.config.max_prepared_stmts -- maximum number of prepared statements
        max_prepared_stmts: 1000
        # @schema {"name": "manager.backup.cassandra.config.max_routing_key_info", "type": "integer"}
        # manager.backup.cassandra.config.max_routing_key_info -- maximum number of routing key info
        max_routing_key_info: 1000
        # @schema {"name": "manager.backup.cassandra.config.page_size", "type": "integer"}
        # manager.backup.cassandra.config.page_size -- page size
        page_size: 5000
        # @schema {"name": "manager.backup.cassandra.config.tls", "alias": "tls"}
        tls:
          # manager.backup.cassandra.config.tls.enabled -- TLS enabled
          enabled: false
          # manager.backup.cassandra.config.tls.cert -- path to TLS cert
          cert: /path/to/cert
          # manager.backup.cassandra.config.tls.key -- path to TLS key
          key: /path/to/key
          # manager.backup.cassandra.config.tls.ca -- path to TLS ca
          ca: /path/to/ca
        # @schema {"name": "manager.backup.cassandra.config.tcp", "alias": "tcp"}
        tcp:
          dns:
            # manager.backup.cassandra.config.tcp.dns.cache_enabled -- TCP DNS cache enabled
            cache_enabled: true
            # manager.backup.cassandra.config.tcp.dns.refresh_duration -- TCP DNS cache refresh duration
            refresh_duration: 5m
            # manager.backup.cassandra.config.tcp.dns.cache_expiration -- TCP DNS cache expiration
            cache_expiration: 24h
          dialer:
            # manager.backup.cassandra.config.tcp.dialer.timeout -- TCP dialer timeout
            timeout: 30s
            # manager.backup.cassandra.config.tcp.dialer.keep_alive -- TCP dialer keep alive
            keep_alive: 10m
            # manager.backup.cassandra.config.tcp.dialer.dual_stack_enabled -- TCP dialer dual stack enabled
            dual_stack_enabled: false
        # @schema {"name": "manager.backup.cassandra.config.enable_host_verification", "type": "boolean"}
        # manager.backup.cassandra.config.enable_host_verification -- host verification enabled
        enable_host_verification: false
        # @schema {"name": "manager.backup.cassandra.config.default_timestamp", "type": "boolean"}
        # manager.backup.cassandra.config.default_timestamp -- default timestamp enabled
        default_timestamp: true
        # @schema {"name": "manager.backup.cassandra.config.reconnect_interval", "type": "string"}
        # manager.backup.cassandra.config.reconnect_interval -- interval of reconnection
        reconnect_interval: 100ms
        # @schema {"name": "manager.backup.cassandra.config.max_wait_schema_agreement", "type": "string"}
        # manager.backup.cassandra.config.max_wait_schema_agreement -- maximum duration to wait for schema agreement
        max_wait_schema_agreement: 1m
        # @schema {"name": "manager.backup.cassandra.config.ignore_peer_addr", "type": "boolean"}
        # manager.backup.cassandra.config.ignore_peer_addr -- ignore peer addresses
        ignore_peer_addr: false
        # @schema {"name": "manager.backup.cassandra.config.disable_initial_host_lookup", "type": "boolean"}
        # manager.backup.cassandra.config.disable_initial_host_lookup -- initial host lookup disabled
        disable_initial_host_lookup: false
        # @schema {"name": "manager.backup.cassandra.config.disable_node_status_events", "type": "boolean"}
        # manager.backup.cassandra.config.disable_node_status_events -- node status events disabled
        disable_node_status_events: false
        # @schema {"name": "manager.backup.cassandra.config.disable_topology_events", "type": "boolean"}
        # manager.backup.cassandra.config.disable_topology_events -- topology events disabled
        disable_topology_events: false
        # @schema {"name": "manager.backup.cassandra.config.disable_skip_metadata", "type": "boolean"}
        # manager.backup.cassandra.config.disable_skip_metadata -- skip metadata disabled
        disable_skip_metadata: false
        # @schema {"name": "manager.backup.cassandra.config.default_idempotence", "type": "boolean"}
        # manager.backup.cassandra.config.default_idempotence -- default idempotence enabled
        default_idempotence: false
        # @schema {"name": "manager.backup.cassandra.config.write_coalesce_wait_time", "type": "string"}
        # manager.backup.cassandra.config.write_coalesce_wait_time -- write coalesce wait time
        write_coalesce_wait_time: 200µs
        # @schema {"name": "manager.backup.cassandra.config.meta_table", "type": "string"}
        # manager.backup.cassandra.config.meta_table -- table name of backup
        meta_table: meta_vector
        # @schema {"name": "manager.backup.cassandra.config.pool_config", "type": "object"}
        pool_config:
          # @schema {"name": "manager.backup.cassandra.config.pool_config.data_center", "type": "string"}
          # manager.backup.cassandra.config.pool_config.data_center -- name of data center
          data_center: ""
          # @schema {"name": "manager.backup.cassandra.config.pool_config.dc_aware_routing", "type": "boolean"}
          # manager.backup.cassandra.config.pool_config.dc_aware_routing -- data center aware routine enabled
          dc_aware_routing: false
          # @schema {"name": "manager.backup.cassandra.config.pool_config.non_local_replicas_fallback", "type": "boolean"}
          # manager.backup.cassandra.config.pool_config.non_local_replicas_fallback -- non-local replica fallback enabled
          non_local_replicas_fallback: false
          # @schema {"name": "manager.backup.cassandra.config.pool_config.shuffle_replicas", "type": "boolean"}
          # manager.backup.cassandra.config.pool_config.shuffle_replicas -- shuffle replica enabled
          shuffle_replicas: false
          # @schema {"name": "manager.backup.cassandra.config.pool_config.token_aware_host_policy", "type": "boolean"}
          # manager.backup.cassandra.config.pool_config.token_aware_host_policy -- token aware host policy enabled
          token_aware_host_policy: false
        # @schema {"name": "manager.backup.cassandra.config.host_filter", "type": "object"}
        host_filter:
          # @schema {"name": "manager.backup.cassandra.config.host_filter.enabled", "type": "boolean"}
          # manager.backup.cassandra.config.host_filter.enabled -- enables host filtering
          enabled: false
          # @schema {"name": "manager.backup.cassandra.config.host_filter.data_center", "type": "string"}
          # manager.backup.cassandra.config.host_filter.data_center -- name of data center of filtering target
          data_center: ""
          # @schema {"name": "manager.backup.cassandra.config.host_filter.white_list", "type": "array", "items": {"type": "string"}}
          # manager.backup.cassandra.config.host_filter.white_list -- list of white_list which allows each connection
          white_list: []

  # @schema {"name": "manager.index", "type": "object"}
  index:
    # @schema {"name": "manager.index.enabled", "type": "boolean"}
    # manager.index.enabled -- index manager enabled
    enabled: true
    # @schema {"name": "manager.index.version", "alias": "version"}
    # manager.index.version -- version of index manager config
    version: v0.0.0
    # @schema {"name": "manager.index.time_zone", "type": "string"}
    # manager.index.time_zone -- Time zone
    time_zone: ""
    # @schema {"name": "manager.index.logging", "alias": "logging"}
    # manager.index.logging -- logging config (overrides defaults.logging)
    logging: {}
    # @schema {"name": "manager.index.name", "type": "string"}
    # manager.index.name -- name of index manager deployment
    name: vald-manager-index
    # @schema {"name": "manager.index.kind", "type": "string", "enum": ["Deployment", "DaemonSet"]}
    # manager.index.kind -- deployment kind: Deployment or DaemonSet
    kind: Deployment
    # @schema {"name": "manager.index.serviceType", "type": "string", "enum": ["ClusterIP", "LoadBalancer", "NodePort"]}
    # manager.index.serviceType -- service type: ClusterIP, LoadBalancer or NodePort
    serviceType: ClusterIP
    # @schema {"name": "manager.index.externalTrafficPolicy", "type": "string"}
    # manager.index.externalTrafficPolicy -- external traffic policy (can be specified when service type is LoadBalancer or NodePort) : Cluster or Local
    externalTrafficPolicy: ""
    # @schema {"name": "manager.index.progressDeadlineSeconds", "type": "integer"}
    # manager.index.progressDeadlineSeconds -- progress deadline seconds
    progressDeadlineSeconds: 600
    # @schema {"name": "manager.index.replicas", "type": "integer", "minimum": 0}
    # manager.index.replicas -- number of replicas
    replicas: 1
    # @schema {"name": "manager.index.maxUnavailable", "type": "string"}
    # manager.index.maxUnavailable -- maximum number of unavailable replicas
    maxUnavailable: 50%
    # @schema {"name": "manager.index.revisionHistoryLimit", "type": "integer", "minimum": 0}
    # manager.index.revisionHistoryLimit -- number of old history to retain to allow rollback
    revisionHistoryLimit: 2
    # @schema {"name": "manager.index.terminationGracePeriodSeconds", "type": "integer", "minimum": 0}
    # manager.index.terminationGracePeriodSeconds -- duration in seconds pod needs to terminate gracefully
    terminationGracePeriodSeconds: 30
    # @schema {"name": "manager.index.podPriority", "alias": "podPriority"}
    podPriority:
      # manager.index.podPriority.enabled -- index manager pod PriorityClass enabled
      enabled: true
      # manager.index.podPriority.value -- index manager pod PriorityClass value
      value: 1000000
    # @schema {"name": "manager.index.annotations", "type": "object"}
    # manager.index.annotations -- deployment annotations
    annotations: {}
    # @schema {"name": "manager.index.podAnnotations", "type": "object"}
    # manager.index.podAnnotations -- pod annotations
    podAnnotations: {}
    # @schema {"name": "manager.index.service", "alias": "service"}
    service:
      # manager.index.service.annotations -- service annotations
      annotations: {}
      # manager.index.service.labels -- service labels
      labels: {}
    # @schema {"name": "manager.index.image", "alias": "image"}
    image:
      # manager.index.image.repository -- image repository
      repository: vdaas/vald-manager-index
      # manager.index.image.tag -- image tag (overrides defaults.image.tag)
      tag: ""
      # manager.index.image.pullPolicy -- image pull policy
      pullPolicy: Always
    # @schema {"name": "manager.index.rollingUpdate", "alias": "rollingUpdate"}
    rollingUpdate:
      # manager.index.rollingUpdate.maxSurge -- max surge of rolling update
      maxSurge: 25%
      # manager.index.rollingUpdate.maxUnavailable -- max unavailable of rolling update
      maxUnavailable: 25%
    # @schema {"name": "manager.index.initContainers", "alias": "initContainers"}
    # manager.index.initContainers -- init containers
    initContainers:
      - type: wait-for
        name: wait-for-agent
        target: agent
        image: busybox
        sleepDuration: 2
      - type: wait-for
        name: wait-for-discoverer
        target: discoverer
        image: busybox
        sleepDuration: 2
    # @schema {"name": "manager.index.env", "alias": "env"}
    # manager.index.env -- environment variables
    env:
      # - name: MY_NODE_NAME
      #   valueFrom:
      #     fieldRef:
      #       fieldPath: spec.nodeName
      - name: MY_POD_NAMESPACE
        valueFrom:
          fieldRef:
            fieldPath: metadata.namespace
    # @schema {"name": "manager.index.volumeMounts", "alias": "volumeMounts"}
    # manager.index.volumeMounts -- volume mounts
    volumeMounts: []
    # @schema {"name": "manager.index.volumes", "alias": "volumes"}
    # manager.index.volumes -- volumes
    volumes: []
    # @schema {"name": "manager.index.nodeName", "type": "string"}
    # manager.index.nodeName -- node name
    nodeName: ""
    # @schema {"name": "manager.index.nodeSelector", "alias": "nodeSelector"}
    # manager.index.nodeSelector -- node selector
    nodeSelector: {}
    # @schema {"name": "manager.index.tolerations", "alias": "tolerations"}
    # manager.index.tolerations -- tolerations
    tolerations: []
    # @schema {"name": "manager.index.affinity", "alias": "affinity"}
    affinity:
      nodeAffinity:
        # manager.index.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution -- node affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        requiredDuringSchedulingIgnoredDuringExecution:
          # manager.index.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms -- node affinity required node selectors
          nodeSelectorTerms: []
      podAffinity:
        # manager.index.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # manager.index.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
      podAntiAffinity:
        # manager.index.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity preferred scheduling terms
        preferredDuringSchedulingIgnoredDuringExecution: []
        # manager.index.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity required scheduling terms
        requiredDuringSchedulingIgnoredDuringExecution: []
    # @schema {"name": "manager.index.topologySpreadConstraints", "alias": "topologySpreadConstraints"}
    # manager.index.topologySpreadConstraints -- topology spread constraints of index manager pods
    topologySpreadConstraints: []
    # @schema {"name": "manager.index.server_config", "alias": "server_config"}
    # manager.index.server_config -- server config (overrides defaults.server_config)
    server_config:
      servers:
        rest: {}
        grpc: {}
      healths:
        liveness: {}
        readiness: {}
      metrics:
        pprof: {}
        prometheus: {}
    # @schema {"name": "manager.index.observability", "alias": "observability"}
    # manager.index.observability -- observability config (overrides defaults.observability)
    observability:
      jaeger:
        service_name: vald-manager-index
      stackdriver:
        profiler:
          service: vald-manager-index
    # @schema {"name": "manager.index.resources", "alias": "resources"}
    # manager.index.resources -- compute resources
    resources:
      requests:
        cpu: 200m
        memory: 80Mi
      limits:
        cpu: 1000m
        memory: 500Mi
    # @schema {"name": "manager.index.indexer", "type": "object"}
    indexer:
      # @schema {"name": "manager.index.indexer.agent_namespace", "type": "string"}
      # manager.index.indexer.agent_namespace -- namespace of agent pods to manage
      agent_namespace: _MY_POD_NAMESPACE_
      # @schema {"name": "manager.index.indexer.node_name", "type": "string"}
      # manager.index.indexer.node_name -- node name
      node_name: "" # _MY_NODE_NAME_
      # @schema {"name": "manager.index.indexer.concurrency", "type": "integer", "minimum": 1}
      # manager.index.indexer.concurrency -- concurrency
      concurrency: 1
      # @schema {"name": "manager.index.indexer.auto_index_duration_limit", "type": "string"}
      # manager.index.indexer.auto_index_duration_limit -- limit duration of automatic indexing
      auto_index_duration_limit: 30m
      # @schema {"name": "manager.index.indexer.auto_index_check_duration", "type": "string"}
      # manager.index.indexer.auto_index_check_duration -- check duration of automatic indexing
      auto_index_check_duration: 1m
      # @schema {"name": "manager.index.indexer.auto_index_length", "type": "integer"}
      # manager.index.indexer.auto_index_length -- number of cache to trigger automatic indexing
      auto_index_length: 100
      # @schema {"name": "manager.index.indexer.creation_pool_size", "type": "integer"}
      # manager.index.indexer.creation_pool_size -- number of pool size of create index processing
      creation_pool_size: 10000
      # @schema {"name": "manager.index.indexer.discoverer", "type": "object"}
      discoverer:
        # @schema {"name": "manager.index.indexer.discoverer.duration", "type": "string"}
        # manager.index.indexer.discoverer.duration -- refresh duration to discover
        duration: 500ms
        # @schema {"name": "manager.index.indexer.discoverer.discover_client", "alias": "grpc.client"}
        # manager.index.indexer.discoverer.discover_client -- gRPC client for discoverer (overrides defaults.grpc.client)
        discover_client: {}
        # @schema {"name": "manager.index.indexer.discoverer.agent_client", "alias": "grpc.client"}
        # manager.index.indexer.discoverer.agent_client -- gRPC client for agents (overrides defaults.grpc.client)
        agent_client:
          dial_option:
            tcp:
              dialer:
                keep_alive: 15m

# @schema {"name": "meta", "type": "object"}
meta:
  # @schema {"name": "meta.enabled", "type": "boolean"}
  # meta.enabled -- meta enabled
  enabled: true
  # @schema {"name": "meta.version", "alias": "version"}
  # meta.version -- version of meta config
  version: v0.0.0
  # @schema {"name": "meta.time_zone", "type": "string"}
  # meta.time_zone -- Time zone
  time_zone: ""
  # @schema {"name": "meta.logging", "alias": "logging"}
  # meta.logging -- logging config (overrides defaults.logging)
  logging: {}
  # @schema {"name": "meta.name", "type": "string"}
  # meta.name -- name of meta deployment
  name: vald-meta
  # @schema {"name": "meta.kind", "type": "string", "enum": ["Deployment", "DaemonSet"]}
  # meta.kind -- deployment kind: Deployment or DaemonSet
  kind: Deployment
  # @schema {"name": "meta.serviceType", "type": "string", "enum": ["ClusterIP", "LoadBalancer", "NodePort"]}
  # meta.serviceType -- service type: ClusterIP, LoadBalancer or NodePort
  serviceType: ClusterIP
  # @schema {"name": "meta.externalTrafficPolicy", "type": "string"}
  # meta.externalTrafficPolicy -- external traffic policy (can be specified when service type is LoadBalancer or NodePort) : Cluster or Local
  externalTrafficPolicy: ""
  # @schema {"name": "meta.progressDeadlineSeconds", "type": "integer"}
  # meta.progressDeadlineSeconds -- progress deadline seconds
  progressDeadlineSeconds: 600
  # @schema {"name": "meta.minReplicas", "type": "integer", "minimum": 0}
  # meta.minReplicas -- minimum number of replicas.
  # if HPA is disabled, the replicas will be set to this value.
  minReplicas: 2
  # @schema {"name": "meta.maxReplicas", "type": "integer", "minimum": 0}
  # meta.maxReplicas -- maximum number of replicas.
  # if HPA is disabled, this value will be ignored.
  maxReplicas: 10
  # @schema {"name": "meta.maxUnavailable", "type": "string"}
  # meta.maxUnavailable -- maximum number of unavailable replicas
  maxUnavailable: 50%
  # @schema {"name": "meta.revisionHistoryLimit", "type": "integer", "minimum": 0}
  # meta.revisionHistoryLimit -- number of old history to retain to allow rollback
  revisionHistoryLimit: 2
  # @schema {"name": "meta.terminationGracePeriodSeconds", "type": "integer", "minimum": 0}
  # meta.terminationGracePeriodSeconds -- duration in seconds pod needs to terminate gracefully
  terminationGracePeriodSeconds: 30
  # @schema {"name": "meta.podPriority", "alias": "podPriority"}
  podPriority:
    # meta.podPriority.enabled -- meta pod PriorityClass enabled
    enabled: true
    # meta.podPriority.value -- meta pod PriorityClass value
    value: 1000000
  # @schema {"name": "meta.annotations", "type": "object"}
  # meta.annotations -- deployment annotations
  annotations: {}
  # @schema {"name": "meta.podAnnotations", "type": "object"}
  # meta.podAnnotations -- pod annotations
  podAnnotations: {}
  # @schema {"name": "meta.service", "alias": "service"}
  service:
    # meta.service.annotations -- service annotations
    annotations: {}
    # meta.service.labels -- service labels
    labels: {}
  # @schema {"name": "meta.hpa", "alias": "hpa"}
  hpa:
    # meta.hpa.enabled -- HPA enabled
    enabled: true
    # meta.hpa.targetCPUUtilizationPercentage -- HPA CPU utilization percentage
    targetCPUUtilizationPercentage: 80
  # @schema {"name": "meta.image", "alias": "image"}
  image:
    # meta.image.repository -- image repository
    repository: vdaas/vald-meta-redis
    # repository: vdaas/vald-meta-cassandra
    # meta.image.tag -- image tag (overrides defaults.image.tag)
    tag: ""
    # meta.image.pullPolicy -- image pull policy
    pullPolicy: Always
  # @schema {"name": "meta.rollingUpdate", "alias": "rollingUpdate"}
  rollingUpdate:
    # meta.rollingUpdate.maxSurge -- max surge of rolling update
    maxSurge: 25%
    # meta.rollingUpdate.maxUnavailable -- max unavailable of rolling update
    maxUnavailable: 25%
  # @schema {"name": "meta.initContainers", "alias": "initContainers"}
  # meta.initContainers -- init containers
  initContainers:
    - type: wait-for-redis
      name: wait-for-redis
      image: redis:latest
      redis:
        hosts:
          - redis.default.svc.cluster.local
        options:
          - "-a ${REDIS_PASSWORD}"
      sleepDuration: 2
      env:
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: redis-secret
              key: password
    # - type: wait-for-cassandra
    #   name: wait-for-cassandra
    #   image: cassandra:latest
    #   cassandra:
    #     hosts:
    #       - cassandra-0.cassandra.default.svc.cluster.local
    #       - cassandra-1.cassandra.default.svc.cluster.local
    #       - cassandra-2.cassandra.default.svc.cluster.local
    #     options:
    #       - "-uroot"
    #       - "-p${CASSANDRA_PASSWORD}"
    #   sleepDuration: 2
    #   env:
    #   - name: CASSANDRA_PASSWORD
    #     valueFrom:
    #       secretKeyRef:
    #         name: cassandra-secret
    #         key: password
    # - type: wait-for-cassandra
    #   name: wait-for-scylla
    #   image: cassandra:latest
    #   cassandra:
    #     hosts:
    #       - scylla-0.scylla.default.svc.cluster.local
    #       - scylla-1.scylla.default.svc.cluster.local
    #       - scylla-2.scylla.default.svc.cluster.local
    #   sleepDuration: 2
  # @schema {"name": "meta.env", "alias": "env"}
  # meta.env -- environment variables
  env:
    - name: REDIS_PASSWORD
      valueFrom:
        secretKeyRef:
          name: redis-secret
          key: password
    # - name: CASSANDRA_PASSWORD
    #   valueFrom:
    #     secretKeyRef:
    #       name: cassandra-secret
    #       key: password
  # @schema {"name": "meta.volumeMounts", "alias": "volumeMounts"}
  # meta.volumeMounts -- volume mounts
  volumeMounts: []
  # @schema {"name": "meta.volumes", "alias": "volumes"}
  # meta.volumes -- volumes
  volumes: []
  # @schema {"name": "meta.nodeName", "type": "string"}
  # meta.nodeName -- node name
  nodeName: ""
  # @schema {"name": "meta.nodeSelector", "alias": "nodeSelector"}
  # meta.nodeSelector -- node selector
  nodeSelector: {}
  # @schema {"name": "meta.tolerations", "alias": "tolerations"}
  # meta.tolerations -- tolerations
  tolerations: []
  # @schema {"name": "meta.affinity", "alias": "affinity"}
  affinity:
    nodeAffinity:
      # meta.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution -- node affinity preferred scheduling terms
      preferredDuringSchedulingIgnoredDuringExecution: []
      requiredDuringSchedulingIgnoredDuringExecution:
        # meta.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms -- node affinity required node selectors
        nodeSelectorTerms: []
    podAffinity:
      # meta.affinity.podAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod affinity preferred scheduling terms
      preferredDuringSchedulingIgnoredDuringExecution: []
      # meta.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod affinity required scheduling terms
      requiredDuringSchedulingIgnoredDuringExecution: []
    podAntiAffinity:
      # meta.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity preferred scheduling terms
      preferredDuringSchedulingIgnoredDuringExecution: []
      # meta.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution -- pod anti-affinity required scheduling terms
      requiredDuringSchedulingIgnoredDuringExecution: []
  # @schema {"name": "meta.topologySpreadConstraints", "alias": "topologySpreadConstraints"}
  # meta.topologySpreadConstraints -- topology spread constraints of meta pods
  topologySpreadConstraints: []
  # @schema {"name": "meta.server_config", "alias": "server_config"}
  # meta.server_config -- server config (overrides defaults.server_config)
  server_config:
    servers:
      rest: {}
      grpc: {}
    healths:
      liveness: {}
      readiness: {}
    metrics:
      pprof: {}
      prometheus: {}
  # @schema {"name": "meta.observability", "alias": "observability"}
  # meta.observability -- observability config (overrides defaults.observability)
  observability:
    jaeger:
      service_name: vald-meta
    stackdriver:
      profiler:
        service: vald-meta
  # @schema {"name": "meta.resources", "alias": "resources"}
  # meta.resources -- compute resources
  resources:
    requests:
      cpu: 100m
      memory: 40Mi
    limits:
      cpu: 300m
      memory: 100Mi
  # @schema {"name": "meta.redis", "type": "object"}
  redis:
    # @schema {"name": "meta.redis.enabled", "type": "boolean"}
    # meta.redis.enabled -- redis config enabled
    enabled: true
    # @schema {"name": "meta.redis.config", "type": "object"}
    config:
      # @schema {"name": "meta.redis.config.addrs", "type": "array", "items": {"type": "string"}}
      # meta.redis.config.addrs -- redis hosts and ports
      addrs:
        - redis.default.svc.cluster.local:6379
      # @schema {"name": "meta.redis.config.db", "type": "integer"}
      # meta.redis.config.db -- database to be selected
      db: 0
      # @schema {"name": "meta.redis.config.dial_timeout", "type": "string"}
      # meta.redis.config.dial_timeout -- dial timeout
      dial_timeout: 5s
      # @schema {"name": "meta.redis.config.idle_check_frequency", "type": "string"}
      # meta.redis.config.idle_check_frequency -- idle check frequency
      idle_check_frequency: 1m
      # @schema {"name": "meta.redis.config.idle_timeout", "type": "string"}
      # meta.redis.config.idle_timeout -- idle timeout
      idle_timeout: 5m
      # @schema {"name": "meta.redis.config.key_pref", "type": "string"}
      # meta.redis.config.key_pref -- key prefix
      key_pref: ""
      # @schema {"name": "meta.redis.config.max_conn_age", "type": "string"}
      # meta.redis.config.max_conn_age -- max connection age
      max_conn_age: 0s
      # @schema {"name": "meta.redis.config.max_redirects", "type": "integer"}
      # meta.redis.config.max_redirects -- max redirects
      max_redirects: 3
      # @schema {"name": "meta.redis.config.max_retries", "type": "integer"}
      # meta.redis.config.max_retries -- max retries
      max_retries: 0
      # @schema {"name": "meta.redis.config.max_retry_backoff", "type": "string"}
      # meta.redis.config.max_retry_backoff -- max retry backoff
      max_retry_backoff: 512ms
      # @schema {"name": "meta.redis.config.min_idle_conns", "type": "integer"}
      # meta.redis.config.min_idle_conns -- min idle connections
      min_idle_conns: 0
      # @schema {"name": "meta.redis.config.min_retry_backoff", "type": "string"}
      # meta.redis.config.min_retry_backoff -- min retry backoff
      min_retry_backoff: 8ms
      # @schema {"name": "meta.redis.config.password", "type": "string"}
      # meta.redis.config.password -- redis password
      password: _REDIS_PASSWORD_
      # @schema {"name": "meta.redis.config.pool_size", "type": "integer"}
      # meta.redis.config.pool_size -- pool size
      pool_size: 10
      # @schema {"name": "meta.redis.config.pool_timeout", "type": "string"}
      # meta.redis.config.pool_timeout -- pool timeout
      pool_timeout: 4s
      # @schema {"name": "meta.redis.config.read_only", "type": "boolean"}
      # meta.redis.config.read_only -- read only enabled
      read_only: false
      # @schema {"name": "meta.redis.config.read_timeout", "type": "string"}
      # meta.redis.config.read_timeout -- read timeout
      read_timeout: 3s
      # @schema {"name": "meta.redis.config.write_timeout", "type": "string"}
      # meta.redis.config.write_timeout -- write timeout
      write_timeout: 3s
      # @schema {"name": "meta.redis.config.route_by_latency", "type": "boolean"}
      # meta.redis.config.route_by_latency -- latency based routing enabled
      route_by_latency: false
      # @schema {"name": "meta.redis.config.route_randomly", "type": "boolean"}
      # meta.redis.config.route_randomly -- random routing enabled
      route_randomly: true
      # @schema {"name": "meta.redis.config.tls", "alias": "tls"}
      tls:
        # meta.redis.config.tls.enabled -- TLS enabled
        enabled: false
        # meta.redis.config.tls.cert -- path to TLS cert
        cert: /path/to/cert
        # meta.redis.config.tls.key -- path to TLS key
        key: /path/to/key
        # meta.redis.config.tls.ca -- path to TLS ca
        ca: /path/to/ca
      # @schema {"name": "meta.redis.config.tcp", "alias": "tcp"}
      tcp:
        dns:
          # meta.redis.config.tcp.dns.cache_enabled -- TCP DNS cache enabled
          cache_enabled: true
          # meta.redis.config.tcp.dns.refresh_duration -- TCP DNS cache refresh duration
          refresh_duration: 1h
          # meta.redis.config.tcp.dns.cache_expiration -- TCP DNS cache expiration
          cache_expiration: 24h
        dialer:
          # meta.redis.config.tcp.dialer.timeout -- TCP dialer timeout
          timeout: 5s
          # meta.redis.config.tcp.dialer.keep_alive -- TCP dialer keep alive
          keep_alive: 5m
          # meta.redis.config.tcp.dialer.dual_stack_enabled -- TCP dialer dual stack enabled
          dual_stack_enabled: false
        tls:
          # meta.redis.config.tcp.tls.enabled -- TCP TLS enabled
          enabled: false
          # meta.redis.config.tcp.tls.cert -- path to TCP TLS cert
          cert: /path/to/cert
          # meta.redis.config.tcp.tls.key -- path to TCP TLS key
          key: /path/to/key
          # meta.redis.config.tcp.tls.ca -- path to TCP TLS ca
          ca: /path/to/ca
      # @schema {"name": "meta.redis.config.kv_prefix", "type": "string"}
      # meta.redis.config.kv_prefix -- KV prefix
      kv_prefix: ""
      # @schema {"name": "meta.redis.config.vk_prefix", "type": "string"}
      # meta.redis.config.vk_prefix -- VK prefix
      vk_prefix: ""
      # @schema {"name": "meta.redis.config.prefix_delimiter", "type": "string"}
      # meta.redis.config.prefix_delimiter -- prefix delimiter
      prefix_delimiter: ""
  # @schema {"name": "meta.cassandra", "alias": "cassandra"}
  cassandra:
    # meta.cassandra.enabled -- cassandra config enabled
    enabled: false
    config:
      # meta.cassandra.config.hosts -- cassandra hosts
      hosts:
        - cassandra-0.cassandra.default.svc.cluster.local
        - cassandra-1.cassandra.default.svc.cluster.local
        - cassandra-2.cassandra.default.svc.cluster.local
        # - scylla-0.scylla.default.svc.cluster.local
        # - scylla-1.scylla.default.svc.cluster.local
        # - scylla-2.scylla.default.svc.cluster.local
      # meta.cassandra.config.cql_version -- cassandra CQL version
      cql_version: 3.0.0
      # meta.cassandra.config.proto_version -- cassandra proto version
      proto_version: 0
      # meta.cassandra.config.timeout -- timeout
      timeout: 600ms
      # meta.cassandra.config.connect_timeout -- connect timeout
      connect_timeout: 3s
      # meta.cassandra.config.port -- cassandra port
      port: 9042
      # meta.cassandra.config.keyspace -- cassandra keyspace
      keyspace: vald
      # meta.cassandra.config.num_conns -- number of connections per hosts
      num_conns: 2
      # meta.cassandra.config.consistency -- consistency type
      consistency: quorum
      # meta.cassandra.config.serial_consistency -- read consistency type
      serial_consistency: localserial
      # meta.cassandra.config.username -- cassandra username
      username: root
      # meta.cassandra.config.password -- cassandra password
      password: _CASSANDRA_PASSWORD_
      retry_policy:
        # meta.cassandra.config.retry_policy.num_retries -- number of retries
        num_retries: 3
        # meta.cassandra.config.retry_policy.min_duration -- minimum duration to retry
        min_duration: 10ms
        # meta.cassandra.config.retry_policy.max_duration -- maximum duration to retry
        max_duration: 1s
      reconnection_policy:
        # meta.cassandra.config.reconnection_policy.max_retries -- maximum number of retries to reconnect
        max_retries: 3
        # meta.cassandra.config.reconnection_policy.initial_interval -- initial interval to reconnect
        initial_interval: 100ms
      # meta.cassandra.config.socket_keepalive -- socket keep alive time
      socket_keepalive: 0s
      # meta.cassandra.config.max_prepared_stmts -- maximum number of prepared statements
      max_prepared_stmts: 1000
      # meta.cassandra.config.max_routing_key_info -- maximum number of routing key info
      max_routing_key_info: 1000
      # meta.cassandra.config.page_size -- page size
      page_size: 5000
      tls:
        # meta.cassandra.config.tls.enabled -- TLS enabled
        enabled: false
        # meta.cassandra.config.tls.cert -- path to TLS cert
        cert: /path/to/cert
        # meta.cassandra.config.tls.key -- path to TLS key
        key: /path/to/key
        # meta.cassandra.config.tls.ca -- path to TLS ca
        ca: /path/to/ca
      tcp:
        dns:
          # meta.cassandra.config.tcp.dns.cache_enabled -- TCP DNS cache enabled
          cache_enabled: true
          # meta.cassandra.config.tcp.dns.refresh_duration -- TCP DNS cache refresh duration
          refresh_duration: 5m
          # meta.cassandra.config.tcp.dns.cache_expiration -- TCP DNS cache expiration
          cache_expiration: 24h
        dialer:
          # meta.cassandra.config.tcp.dialer.timeout -- TCP dialer timeout
          timeout: 30s
          # meta.cassandra.config.tcp.dialer.keep_alive -- TCP dialer keep alive
          keep_alive: 10m
          # meta.cassandra.config.tcp.dialer.dual_stack_enabled -- TCP dialer dual stack enabled
          dual_stack_enabled: false
      # meta.cassandra.config.enable_host_verification -- host verification enabled
      enable_host_verification: false
      # meta.cassandra.config.default_timestamp -- default timestamp enabled
      default_timestamp: true
      # meta.cassandra.config.reconnect_interval -- interval of reconnection
      reconnect_interval: 100ms
      # meta.cassandra.config.max_wait_schema_agreement -- maximum duration to wait for schema agreement
      max_wait_schema_agreement: 1m
      # meta.cassandra.config.ignore_peer_addr -- ignore peer addresses
      ignore_peer_addr: false
      # meta.cassandra.config.disable_initial_host_lookup -- initial host lookup disabled
      disable_initial_host_lookup: false
      # meta.cassandra.config.disable_node_status_events -- node status events disabled
      disable_node_status_events: false
      # meta.cassandra.config.disable_topology_events -- topology events disabled
      disable_topology_events: false
      # meta.cassandra.config.disable_skip_metadata -- skip metadata disabled
      disable_skip_metadata: false
      # meta.cassandra.config.default_idempotence -- default idempotence enabled
      default_idempotence: false
      # meta.cassandra.config.write_coalesce_wait_time -- write coalesce wait time
      write_coalesce_wait_time: 200µs
      # meta.cassandra.config.meta_table -- table name of backup
      meta_table: meta_vector
      pool_config:
        # meta.cassandra.config.pool_config.data_center -- name of data center
        data_center: ""
        # meta.cassandra.config.pool_config.dc_aware_routing -- data center aware routine enabled
        dc_aware_routing: false
        # meta.cassandra.config.pool_config.non_local_replicas_fallback -- non-local replica fallback enabled
        non_local_replicas_fallback: false
        # meta.cassandra.config.pool_config.shuffle_replicas -- shuffle replica enabled
        shuffle_replicas: false
        # meta.cassandra.config.pool_config.token_aware_host_policy -- token aware host policy enabled
        token_aware_host_policy: false
      host_filter:
        # meta.cassandra.config.host_filter.enabled -- enables host filtering
        enabled: false
        # meta.cassandra.config.host_filter.data_center -- name of data center of filtering target
        data_center: ""
        # meta.cassandra.config.host_filter.white_list -- list of white_list which allows each connection
        white_list: []

initializer:
  mysql:
    # initializer.mysql.enabled -- mysql initializer job enabled
    enabled: false
    # initializer.mysql.name -- mysql initializer job name
    name: mysql-init
    image:
      # initializer.mysql.image.repository -- image repository
      repository: mysql
      # initializer.mysql.image.tag -- image tag
      tag: latest
      # initializer.mysql.image.pullPolicy -- image pull policy
      pullPolicy: Always
    # initializer.mysql.restartPolicy -- restart policy
    restartPolicy: Never
    # initializer.mysql.env -- environment variables
    env:
      - name: MYSQL_HOST
        value: mysql.default.svc.cluster.local
      - name: MYSQL_USER
        value: root
      - name: MYSQL_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysql-secret
            key: password
    configmap:
      # initializer.mysql.configmap.enabled -- mysql schema configmap will be created
      enabled: false
      # initializer.mysql.configmap.name -- mysql schema configmap name
      name: mysql-config
      # initializer.mysql.configmap.filename -- mysql schema filename
      filename: ddl.sql
      # initializer.mysql.configmap.schema -- mysql schema name
      schema: vald
    secret:
      # initializer.mysql.secret.enabled -- mysql secret will be created
      enabled: false
      # initializer.mysql.secret.name -- mysql secret name
      name: mysql-secret
      # initializer.mysql.secret.data -- mysql secret data
      data:
        password: cGFzc3dvcmQ=
  redis:
    # initializer.redis.enabled -- redis initializer job enabled
    enabled: false
    # initializer.redis.name -- redis initializer job name
    name: redis-init
    image:
      # initializer.redis.image.repository -- image repository
      repository: redis
      # initializer.redis.image.tag -- image tag
      tag: latest
      # initializer.redis.image.pullPolicy -- image pull policy
      pullPolicy: Always
    # initializer.redis.restartPolicy -- restart policy
    restartPolicy: Never
    # initializer.redis.env -- environment variables
    env:
      - name: REDIS_HOST
        value: redis.default.svc.cluster.local
      - name: REDIS_PASSWORD
        valueFrom:
          secretKeyRef:
            name: redis-secret
            key: password
    secret:
      # initializer.redis.secret.enabled -- redis secret will be created
      enabled: false
      # initializer.redis.secret.name -- redis secret name
      name: redis-secret
      # initializer.redis.secret.data -- redis secret data
      data:
        password: cGFzc3dvcmQ=
  cassandra:
    # initializer.cassandra.enabled -- cassandra initializer job enabled
    enabled: false
    # initializer.cassandra.name -- cassandra initializer job name
    name: cassandra-init
    image:
      # initializer.cassandra.image.repository -- image repository
      repository: cassandra
      # initializer.cassandra.image.tag -- image tag
      tag: latest
      # initializer.cassandra.image.pullPolicy -- image pull policy
      pullPolicy: Always
    # initializer.cassandra.restartPolicy -- restart policy
    restartPolicy: Never
    # initializer.cassandra.env -- environment variables
    env:
      - name: CASSANDRA_HOST
        value: cassandra.default.svc.cluster.local
      - name: CASSANDRA_USER
        value: root
      - name: CASSANDRA_PASSWORD
        valueFrom:
          secretKeyRef:
            name: cassandra-secret
            key: password
    configmap:
      # initializer.cassandra.configmap.enabled -- cassandra schema configmap will be created
      enabled: false
      # initializer.cassandra.configmap.name -- cassandra schema configmap name
      name: cassandra-initdb
      # initializer.cassandra.configmap.filename -- cassandra schema filename
      filename: init.cql
      # initializer.cassandra.configmap.keyspace -- cassandra keyspace
      keyspace: vald
      # initializer.cassandra.configmap.replication_class -- cassandra replication class
      replication_class: SimpleStrategy
      # initializer.cassandra.configmap.replication_factor -- cassandra replication factor
      replication_factor: 3
      meta:
        # initializer.cassandra.configmap.meta.enabled -- meta table enabled
        enabled: true
        name:
          # initializer.cassandra.configmap.meta.name.kv -- name of KV table
          kv: kv
          # initializer.cassandra.configmap.meta.name.vk -- name of VK table
          vk: vk
      backup:
        # initializer.cassandra.configmap.backup.enabled -- backup table enabled
        enabled: true
        # initializer.cassandra.configmap.backup.name -- name of backup table
        name: meta_vector
    secret:
      # initializer.cassandra.secret.enabled -- cassandra secret will be created
      enabled: false
      # initializer.cassandra.secret.name -- cassandra secret name
      name: cassandra-secret
      # initializer.cassandra.secret.data -- cassandra secret data
      data:
        password: cGFzc3dvcmQ=
