//
// Copyright (C) 2019-2024 vdaas.org vald team <vald@vdaas.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package main

import (
	"bytes"
	"context"
	"io/fs"
	"os"
	"os/signal"
	"regexp"
	"slices"
	"syscall"
	"text/template"
	"time"

	"github.com/vdaas/vald/internal/errors"
	"github.com/vdaas/vald/internal/file"
	"github.com/vdaas/vald/internal/log"
	"github.com/vdaas/vald/internal/safety"
	"github.com/vdaas/vald/internal/strings"
	"github.com/vdaas/vald/internal/sync/errgroup"
)

const tmpl = `# syntax = docker/dockerfile:latest
#
# Copyright (C) 2019-{{.Year}} {{.Maintainer}}
#
# Licensed under the Apache License, Version 2.0 (the "License");
# You may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# DO_NOT_EDIT this Dockerfile is generated by hack/docker/gen/main.go

ARG UPX_OPTIONS=-9

{{- range $key, $value := .Arguments }}
ARG {{$key}}={{$value}}
{{- end}}
{{- range $image := .ExtraImages }}
# skipcq: DOK-DL3026,DOK-DL3007
FROM {{$image}}
{{- end}}
# skipcq: DOK-DL3026,DOK-DL3007
FROM {{.BuilderImage}}:{{.BuilderTag}}{{- if not .DevContainer}} AS builder {{- end}}
ARG MAINTAINER="{{.Maintainer}}"
LABEL maintainer="${MAINTAINER}"

# skipcq: DOK-DL3002
USER {{.BuildUser}}

ARG TARGETARCH
ARG TARGETOS
ARG GO_VERSION
ARG RUST_VERSION

{{- range $keyValue := .EnvironmentsSlice }}
ENV {{$keyValue}}
{{- end}}

SHELL ["/bin/bash", "-o", "pipefail", "-c"]
#skipcq: DOK-W1001, DOK-SC2046, DOK-SC2086, DOK-DL3008
RUN rm -f /etc/apt/apt.conf.d/docker-clean \
    && echo 'Binary::apt::APT::Keep-Downloaded-Packages "true";' > /etc/apt/apt.conf.d/keep-cache \
    && echo 'APT::Install-Recommends "false";' > /etc/apt/apt.conf.d/no-install-recommends \
    && apt-get clean \
    && rm -rf \
        /var/lib/apt/lists/* \
        /var/cache/* \
    && apt-get update -y \
    && apt-get upgrade -y \
{{- if .DevContainer}}
    && apt-get install -y --no-install-recommends --fix-missing \
    curl \
    gnupg \
    software-properties-common \
    && add-apt-repository ppa:ubuntu-toolchain-r/test -y \
    && apt-get update -y \
    && apt-get upgrade -y \
{{- end}}
    && apt-get install -y --no-install-recommends --fix-missing \
    build-essential \
    ca-certificates \
{{- if not .DevContainer}}
    curl \
{{- end}}
    tzdata \
    locales \
    git \
{{- range $epkg := .ExtraPackages }}
    {{$epkg}} \
{{- end}}
    && ldconfig \
    && echo "${LANG} UTF-8" > /etc/locale.gen \
    && ln -fs /usr/share/zoneinfo/${TZ} /etc/localtime \
    && locale-gen ${LANGUAGE} \
    && update-locale LANG=${LANGUAGE} \
    && dpkg-reconfigure -f noninteractive tzdata \
    && apt-get clean \
    && apt-get autoclean -y \
    && rm -rf \
        /var/lib/apt/lists/* \
        /var/cache/* \
    && apt-get autoremove -y

WORKDIR {{.RootDir}}/${ORG}/${REPO}
COPY Makefile .
COPY .git .
{{- if not .DevContainer}}
{{- if eq .ContainerType 0 }}
COPY go.mod .
COPY go.sum .
{{- else if eq .ContainerType 3 }}
COPY go.mod .
COPY go.sum .
{{- end}}
{{- if .ConfigExists }}
COPY cmd/${PKG}/sample.yaml {{$.TmpConfigPath}}
{{- end}}

{{- range $files := .CopyDirectories }}
WORKDIR {{$.RootDir}}/${ORG}/${REPO}/{{$files}}
COPY {{$files}} .
{{- end}}
{{- else}}
WORKDIR {{.RootDir}}/${ORG}/${REPO}
COPY . .
{{- end}}
{{- range $files := .ExtraCopies }}
COPY {{$files}}
{{- end}}

WORKDIR {{.RootDir}}/${ORG}/${REPO}
{{- if .RunCommands}}
#skipcq: DOK-W1001, DOK-SC2046, DOK-SC2086, DOK-DL3008
RUN {{RunCommands .RunCommands}}
{{- end}}

{{- if not .DevContainer}}
# skipcq: DOK-DL3026,DOK-DL3007
FROM {{.RuntimeImage}}:{{.RuntimeTag}}
ARG MAINTAINER="{{.Maintainer}}"
LABEL maintainer="${MAINTAINER}"

ENV APP_NAME={{.AppName}}

COPY --from=builder {{.BinDir}}/${APP_NAME} {{.BinDir}}/${APP_NAME}
{{- if .ConfigExists }}
COPY --from=builder {{$.TmpConfigPath}} /etc/server/config.yaml
{{- end}}
{{- range $from, $file := .StageFiles }}
COPY --from=builder {{$file}} {{$file}}
{{- end}}
{{- end}}
# skipcq: DOK-DL3002
USER {{.RuntimeUser}}

{{- if .Entrypoints}}
ENTRYPOINT [{{Entrypoint .Entrypoints}}]
{{- else if not .DevContainer}}
ENTRYPOINT ["{{.BinDir}}/{{.AppName}}"]
{{- end}}
`

var docker = template.Must(template.New("Dockerfile").Funcs(template.FuncMap{
	"RunCommands": func(commands []string) string {
		if len(commands) == 0 {
			return ""
		}
		var b strings.Builder
		for i, cmd := range commands {
			if i > 0 {
				b.WriteString(" \\\n    && ")
			}
			b.WriteString(cmd)
		}
		return b.String()
	},
	"Entrypoint": func(entries []string) string {
		if len(entries) == 0 {
			return "\"{{.BinDir}}/{{.AppName}}\""
		}
		return "\"" + strings.Join(entries, "\", \"") + "\""
	},
}).Parse(tmpl))

type Data struct {
	ConfigExists      bool
	DevContainer      bool
	Year              int
	ContainerType     ContainerType
	AppName           string
	BinDir            string
	BuildUser         string
	BuilderImage      string
	BuilderTag        string
	Maintainer        string
	PackageDir        string
	RootDir           string
	RuntimeImage      string
	RuntimeTag        string
	RuntimeUser       string
	TmpConfigPath     string
	Arguments         map[string]string
	Environments      map[string]string
	Entrypoints       []string
	EnvironmentsSlice []string
	CopyDirectories   []string
	ExtraCopies       []string
	ExtraImages       []string
	ExtraPackages     []string
	Preprocess        []string
	RunCommands       []string
	StageFiles        []string
}

type ContainerType int

const (
	organization          = "vdaas"
	repository            = "vald"
	defaultBinaryDir      = "/usr/bin"
	defaultBuilderImage   = "ghcr.io/vdaas/vald/vald-buildbase"
	defaultBuilderTag     = "nightly"
	defaultLanguage       = "en_US.UTF-8"
	defaultMaintainer     = organization + ".org " + repository + " team <" + repository + "@" + organization + ".org>"
	defaultRuntimeImage   = "gcr.io/distroless/static"
	defaultRuntimeTag     = "nonroot"
	defaultTmpConfigPath  = "/tmp/config.yaml"
	defaultRuntimeUser    = "nonroot:nonroot"
	defaultBuildUser      = "root:root"
	maintainerKey         = "MAINTAINER"
	minimumArgumentLength = 2
	ubuntuVersion         = "22.04"

	goWorkdir   = "${GOPATH}/src/github.com"
	rustWorkdir = "${HOME}/rust/src/github.com"

	agentInernalPackage = "pkg/agent/internal"

	ngtPreprocess   = "make ngt/install"
	faissPreprocess = "make faiss/install"

	helmOperatorRootdir   = "/opt/helm"
	helmOperatorWatchFile = helmOperatorRootdir + "/watches.yaml"
	helmOperatorChartsDir = helmOperatorRootdir + "/charts"
)

const (
	Go ContainerType = iota
	Rust
	DevContainer
	HelmOperator
	Other
)

var (
	defaultEnvironments = map[string]string{
		"DEBIAN_FRONTEND": "noninteractive",
		"HOME":            "/root",
		"USER":            "root",
		"INITRD":          "No",
		"LANG":            defaultLanguage,
		"LANGUAGE":        defaultLanguage,
		"LC_ALL":          defaultLanguage,
		"ORG":             organization,
		"TZ":              "Etc/UTC",
		"PATH":            "${PATH}:/usr/local/bin",
		"REPO":            repository,
	}
	goDefaultEnvironments = map[string]string{
		"GOROOT":      "/opt/go",
		"GOPATH":      "/go",
		"GO111MODULE": "on",
		"PATH":        "${PATH}:${GOROOT}/bin:${GOPATH}/bin:/usr/local/bin",
	}
	rustDefaultEnvironments = map[string]string{
		"RUST_HOME":   "/usr/loacl/lib/rust",
		"RUSTUP_HOME": "${RUST_HOME}/rustup",
		"CARGO_HOME":  "${RUST_HOME}/cargo",
		"PATH":        "${PATH}:${RUSTUP_HOME}/bin:${CARGO_HOME}/bin:/usr/local/bin",
	}
	clangDefaultEnvironments = map[string]string{
		"CC":  "gcc",
		"CXX": "g++",
	}

	defaultCopyDirectories = []string{
		"Makefile.d",
		"versions",
	}
	goDefaultCopyDirectories = []string{
		"internal",
		"apis/grpc",
		"pkg/${PKG}",
		"cmd/${PKG}",
	}
	rustDefaultCopyDirectories = []string{
		"rust",
	}

	goInstallCommands = []string{
		`--mount=type=cache,target="${GOPATH}/pkg",id="go-build-${TARGETARCH}" \
    --mount=type=cache,target="${HOME}/.cache/go-build",id="go-build-${TARGETARCH}" \
    make GO_VERSION="${GO_VERSION}" go/install`,
		"make go/download",
	}
	rustInstallCommands = []string{
		"make RUST_VERSION=\"${RUST_VERSION}\" rust/install",
	}
	goBuildCommands = []string{
		"make GOARCH=\"${TARGETARCH}\" GOOS=\"${TARGETOS}\" REPO=\"${ORG}\" NAME=\"${REPO}\" cmd/${PKG}/${APP_NAME}",
		"mv \"cmd/${PKG}/${APP_NAME}\" \"{{$.BinDir}}/${APP_NAME}\"",
	}
	rustBuildCommands = []string{
		"make rust/target/release/${APP_NAME}",
		"mv \"rust/target/release/${APP_NAME}\" \"{{$.BinDir}}/${APP_NAME}\"",
		"rm -rf rust/target",
	}

	clangBuildDeps = []string{
		"cmake",
		"gcc",
		"g++",
		"unzip",
		"libssl-dev",
	}
	ngtBuildDeps = []string{
		"liblapack-dev",
		"libomp-dev",
		"libopenblas-dev",
	}
	faissBuildDeps = []string{
		"gfortran",
	}
	devContainerDeps = []string{
		"gawk",
		"gnupg2",
		"graphviz",
		"jq",
		"libhdf5-dev",
		"libaec-dev",
		"sed",
		"zip",
	}

	ciContainerPreprocess = []string{
		"curl -fsSL https://deb.nodesource.com/setup_current.x | bash -",
		"apt-get clean",
		"rm -rf /var/lib/apt/lists/* /var/cache/*",
		"apt-get update -y",
		"apt-get upgrade -y",
		"apt-get install -y --no-install-recommends --fix-missing nodejs",
		"npm install -g npm@latest",
		"apt-get clean",
		"apt-get autoclean -y",
		"rm -rf /var/lib/apt/lists/* /var/cache/*",
		"apt-get autoremove -y",
		"make GOARCH=${TARGETARCH} GOOS=${TARGETOS} deps GO_CLEAN_DEPS=false",
		"make GOARCH=${TARGETARCH} GOOS=${TARGETOS} golangci-lint/install",
		"make GOARCH=${TARGETARCH} GOOS=${TARGETOS} gotestfmt/install",
		"make cmake/install",
		"make buf/install",
		"make hdf5/install",
		"make helm-docs/install",
		"make helm/install",
		"make k3d/install",
		"make k9s/install",
		"make kind/install",
		"make kubectl/install",
		"make kubelinter/install",
		"make reviewdog/install",
		"make tparse/install",
		"make valdcli/install",
		"make yq/install",
		"make minikube/install",
		"make stern/install",
		"make telepresence/install",
	}

	devContainerPreprocess = []string{
		"echo \"installing golang vscode extension dependencies\"",
		"make delve/install",
		"make gomodifytags/install",
		"make gopls/install",
		"make gotests/install",
		"make impl/install",
		"make staticcheck/install",
	}
)

func appendM[K comparable](maps ...map[K]string) map[K]string {
	if len(maps) == 0 {
		return nil
	}
	result := maps[0]
	for _, m := range maps[1:] {
		for k, v := range m {
			ev, ok := result[k]
			if ok {
				v += ":" + ev
			}
			result[k] = v
		}
	}

	for k, v := range result {
		vs := strings.Split(v, ":")
		slices.Sort(vs)
		v = strings.Join(slices.Compact(vs), ":")
		if strings.Contains(v, "${PATH}:") {
			v = strings.TrimPrefix(strings.ReplaceAll(strings.ReplaceAll(v, "${PATH}", ""), "::", ":")+":${PATH}", ":")
		}
		if strings.Contains(v, ":unix") {
			v = "unix:" + strings.TrimSuffix(v, ":unix")
		}
		result[k] = v
	}
	return result
}

var re = regexp.MustCompile(`\$\{?(\w+)\}?`)

func extractVariables(value string) []string {
	matches := re.FindAllStringSubmatch(value, -1)
	vars := make([]string, 0, len(matches))
	for _, match := range matches {
		vars = append(vars, match[1])
	}
	return vars
}

func topologicalSort(envMap map[string]string) []string {
	// Graph structures
	inDegree := make(map[string]int)
	graph := make(map[string][]string)

	// Initialize the graph
	for key, value := range envMap {
		vars := extractVariables(value)
		for _, refKey := range vars {
			if refKey != key {
				graph[refKey] = append(graph[refKey], key)
				inDegree[key]++
			}
		}
	}

	queue := make([]string, 0, len(envMap)-len(graph))
	for key := range envMap {
		if inDegree[key] == 0 {
			queue = append(queue, key)
		}
	}

	slices.Sort(queue)

	// Topological sort
	result := make([]string, 0, len(envMap))
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		if value, exists := envMap[node]; exists {
			result = append(result, node+"="+value)
		}
		for _, neighbor := range graph[node] {
			inDegree[neighbor]--
			if inDegree[neighbor] == 0 {
				queue = append(queue, neighbor)
			}
		}
	}

	return result
}

func main() {
	log.Init()
	if len(os.Args) < minimumArgumentLength {
		// skipcq: RVV-A0003
		log.Fatal(errors.New("invalid argument"))
	}

	ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGINT,
		syscall.SIGQUIT,
		syscall.SIGHUP,
		syscall.SIGALRM,
		syscall.SIGKILL,
		syscall.SIGTERM)
	defer cancel()

	maintainer := os.Getenv(maintainerKey)
	if maintainer == "" {
		maintainer = defaultMaintainer
	}
	year := time.Now().Year()
	eg, egctx := errgroup.New(ctx)
	for n, d := range map[string]Data{
		"vald-agent-ngt": {
			AppName:         "ngt",
			PackageDir:      "agent/core/ngt",
			CopyDirectories: []string{agentInernalPackage},
			ExtraPackages:   append(clangBuildDeps, ngtBuildDeps...),
			Preprocess:      []string{ngtPreprocess},
		},
		"vald-agent-faiss": {
			AppName:         "faiss",
			PackageDir:      "agent/core/faiss",
			CopyDirectories: []string{agentInernalPackage},
			ExtraPackages: append(clangBuildDeps,
				append(ngtBuildDeps,
					faissBuildDeps...)...),
			Preprocess: []string{faissPreprocess},
		},
		"vald-agent": {
			AppName:       "agent",
			PackageDir:    "agent/core/agent",
			ContainerType: Rust,
			RuntimeImage:  "gcr.io/distroless/cc-debian12",
			ExtraPackages: append(clangBuildDeps,
				append(ngtBuildDeps,
					faissBuildDeps...)...),
			Preprocess: []string{
				ngtPreprocess,
				faissPreprocess,
			},
		},
		"vald-agent-sidecar": {
			AppName:         "sidecar",
			PackageDir:      "agent/sidecar",
			CopyDirectories: []string{agentInernalPackage},
		},
		"vald-discoverer-k8s": {
			AppName:    "discoverer",
			PackageDir: "discoverer/k8s",
		},
		"vald-gateway-lb": {
			AppName:    "lb",
			PackageDir: "gateway/lb",
		},
		"vald-gateway-filter": {
			AppName:    "filter",
			PackageDir: "gateway/filter",
		},
		"vald-gateway-mirror": {
			AppName:    "mirror",
			PackageDir: "gateway/mirror",
		},
		"vald-manager-index": {
			AppName:    "index",
			PackageDir: "manager/index",
		},
		"vald-index-correction": {
			AppName:    "index-correction",
			PackageDir: "index/job/correction",
		},
		"vald-index-creation": {
			AppName:    "index-creation",
			PackageDir: "index/job/creation",
		},
		"vald-index-save": {
			AppName:    "index-save",
			PackageDir: "index/job/save",
		},
		"vald-readreplica-rotate": {
			AppName:    "readreplica-rotate",
			PackageDir: "index/job/readreplica/rotate",
		},
		"vald-index-operator": {
			AppName:    "index-operator",
			PackageDir: "index/operator",
		},
		"vald-benchmark-job": {
			AppName:       "job",
			PackageDir:    "tools/benchmark/job",
			ExtraPackages: append(clangBuildDeps, "libhdf5-dev", "libaec-dev"),
			Preprocess: []string{
				"make hdf5/install",
			},
		},
		"vald-benchmark-operator": {
			AppName:    "operator",
			PackageDir: "tools/benchmark/operator",
		},
		"vald-helm-operator": {
			AppName:       "helm-operator",
			PackageDir:    "operator/helm",
			ContainerType: HelmOperator,
			Arguments: map[string]string{
				"OPERATOR_SDK_VERSION": "latest",
			},
			CopyDirectories: []string{
				"internal",
				"charts",
				"hack",
			},
			ExtraCopies: []string{
				"--from=operator /usr/local/bin/${APP_NAME} {{$.BinDir}}/${APP_NAME}",
			},
			ExtraImages: []string{
				"quay.io/operator-framework/helm-operator:${OPERATOR_SDK_VERSION} AS operator",
			},
			ExtraPackages: []string{"upx"},
			Preprocess: []string{
				"mkdir -p " + helmOperatorChartsDir,
				`{ \
        echo "---"; \
        echo "- version: v1"; \
        echo "  group: vald.vdaas.org"; \
        echo "  kind: ValdRelease"; \
        echo "  chart: ` + helmOperatorChartsDir + `/vald"; \
        echo "- version: v1"; \
        echo "  group: vald.vdaas.org"; \
        echo "  kind: ValdHelmOperatorRelease"; \
        echo "  chart: ` + helmOperatorChartsDir + `/vald-helm-operator"; \
    } > ` + helmOperatorWatchFile,
				"make GOARCH=${TARGETARCH} GOOS=${TARGETOS} helm/schema/vald",
				"make GOARCH=${TARGETARCH} GOOS=${TARGETOS} helm/schema/vald-helm-operator",
				"cp -r charts/* " + helmOperatorChartsDir + "/",
				"upx \"{{$.BinDir}}/${APP_NAME}\"",
			},
			StageFiles: []string{
				helmOperatorWatchFile,
				helmOperatorChartsDir + "/vald",
				helmOperatorChartsDir + "/vald-helm-operator",
			},
			Entrypoints: []string{"{{$.BinDir}}/{{.AppName}}", "run", "--watches-file=" + helmOperatorWatchFile},
		},
		"vald-cli-loadtest": {
			AppName:       "loadtest",
			PackageDir:    "tools/cli/loadtest",
			ExtraPackages: append(clangBuildDeps, "libhdf5-dev", "libaec-dev"),
			CopyDirectories: []string{
				"hack/benchmark/assets/x1b",
			},
			Preprocess: []string{
				"make hdf5/install",
			},
		},
		"vald-ci-container": {
			AppName:       "ci-container",
			DevContainer:  true,
			ContainerType: DevContainer,
			BuilderImage:  "ghcr.io/actions-runner-controller/actions-runner-controller/actions-runner-dind",
			BuilderTag:    "ubuntu-" + ubuntuVersion,
			PackageDir:    "ci/base",
			RuntimeUser:   defaultBuildUser,
			ExtraPackages: append(clangBuildDeps,
				append(ngtBuildDeps,
					append(faissBuildDeps,
						devContainerDeps...)...)...),
			Preprocess:  append(ciContainerPreprocess, ngtPreprocess, faissPreprocess),
			Entrypoints: []string{"/bin/bash", "-c", "/usr/bin/entrypoint-dind.sh"},
		},
		"vald-dev-container": {
			AppName:       "dev-container",
			BuilderImage:  "mcr.microsoft.com/devcontainers/base",
			BuilderTag:    "ubuntu" + ubuntuVersion,
			BuildUser:     defaultBuildUser,
			RuntimeUser:   defaultBuildUser,
			DevContainer:  true,
			ContainerType: DevContainer,
			PackageDir:    "dev",
			ExtraPackages: append(clangBuildDeps,
				append(ngtBuildDeps,
					append(faissBuildDeps,
						devContainerDeps...)...)...),
			Preprocess: append(ciContainerPreprocess,
				append(devContainerPreprocess,
					ngtPreprocess,
					faissPreprocess)...),
		},
	} {
		name := n
		data := d

		eg.Go(safety.RecoverFunc(func() error {
			data.Maintainer = maintainer
			data.Year = year
			if data.BinDir == "" {
				data.BinDir = defaultBinaryDir
			}
			if data.TmpConfigPath == "" {
				data.TmpConfigPath = defaultTmpConfigPath
			}
			if data.RuntimeImage == "" {
				data.RuntimeImage = defaultRuntimeImage
			}
			if data.RuntimeTag == "" {
				data.RuntimeTag = defaultRuntimeTag
			}
			if data.BuilderImage == "" {
				data.BuilderImage = defaultBuilderImage
			}
			if data.BuilderTag == "" {
				data.BuilderTag = defaultBuilderTag
			}
			if data.RuntimeUser == "" {
				data.RuntimeUser = defaultRuntimeUser
			}

			if data.BuildUser == "" {
				data.BuildUser = defaultBuildUser
			}

			if data.CopyDirectories != nil {
				data.CopyDirectories = append(defaultCopyDirectories, data.CopyDirectories...)
			} else {
				data.CopyDirectories = make([]string, len(defaultCopyDirectories))
				copy(data.CopyDirectories, defaultCopyDirectories)
			}
			if data.Environments != nil {
				data.Environments = appendM(data.Environments, defaultEnvironments)
			} else {
				data.Environments = make(map[string]string, len(defaultEnvironments))
				data.Environments = appendM(data.Environments, defaultEnvironments)
			}
			switch data.ContainerType {
			case Go:
				data.CopyDirectories = append(data.CopyDirectories, goDefaultCopyDirectories...)
				data.Environments = appendM(data.Environments, goDefaultEnvironments)
				data.RootDir = goWorkdir
				commands := make([]string, 0, len(goInstallCommands)+len(data.Preprocess)+len(goBuildCommands))
				commands = append(commands, goInstallCommands...)
				if data.Preprocess != nil {
					commands = append(commands, data.Preprocess...)
				}
				if file.Exists(file.Join(os.Args[1], "cmd", data.PackageDir)) {
					commands = append(commands, goBuildCommands...)
				}
				data.RunCommands = commands
			case Rust:
				data.CopyDirectories = append(data.CopyDirectories, rustDefaultCopyDirectories...)
				data.Environments = appendM(data.Environments, rustDefaultEnvironments)
				data.RootDir = rustWorkdir
				commands := make([]string, 0, len(rustInstallCommands)+len(data.Preprocess)+len(rustBuildCommands))
				commands = append(commands, rustInstallCommands...)
				if data.Preprocess != nil {
					commands = append(commands, data.Preprocess...)
				}
				commands = append(commands, rustBuildCommands...)
				data.RunCommands = commands
			case DevContainer:
				data.CopyDirectories = append(data.CopyDirectories, append(goDefaultCopyDirectories, rustDefaultCopyDirectories...)...)
				data.Environments = appendM(data.Environments, goDefaultEnvironments, rustDefaultEnvironments, clangDefaultEnvironments)
				data.RootDir = goWorkdir
				commands := make([]string, 0, len(goInstallCommands)+len(rustInstallCommands)+len(data.Preprocess)+1)
				commands = append(commands, append(goInstallCommands, rustInstallCommands...)...)
				if data.Preprocess != nil {
					commands = append(commands, data.Preprocess...)
				}
				commands = append(commands, "rm -rf {{.RootDir}}/${ORG}/${REPO}/*")
				data.RunCommands = commands
			case HelmOperator:
				data.Environments = appendM(data.Environments, goDefaultEnvironments)
				data.RootDir = goWorkdir
				commands := make([]string, 0, len(goInstallCommands)+len(data.Preprocess))
				commands = append(commands, goInstallCommands...)
				if data.Preprocess != nil {
					commands = append(commands, data.Preprocess...)
				}
				data.RunCommands = commands
			default:
				data.RootDir = "${HOME}"
				data.Environments["ROOTDIR"] = os.Args[1]
			}
			if strings.Contains(data.BuildUser, "root") {
				data.Environments["HOME"] = "/root"
				data.Environments["USER"] = "root"
			} else {
				user := data.BuildUser
				if strings.Contains(user, ":") {
					user = strings.SplitN(user, ":", 2)[0]
				}
				data.Environments["HOME"] = "/home/" + user
				data.Environments["USER"] = user
			}

			data.Environments["APP_NAME"] = data.AppName
			data.Environments["PKG"] = data.PackageDir
			data.EnvironmentsSlice = topologicalSort(data.Environments)
			data.ConfigExists = file.Exists(file.Join(os.Args[1], "cmd", data.PackageDir, "sample.yaml"))

			buf := bytes.NewBuffer(make([]byte, 0, len(tmpl)))
			log.Infof("Generating %s's Dockerfile", name)
			docker.Execute(buf, data)
			tpl := buf.String()
			buf.Reset()
			template.Must(template.New("Dockerfile").Parse(tpl)).Execute(buf, data)
			file.OverWriteFile(egctx, file.Join(os.Args[1], "dockers", data.PackageDir, "Dockerfile"), buf, fs.ModePerm)
			return nil
		}))
	}
	eg.Wait()
}
