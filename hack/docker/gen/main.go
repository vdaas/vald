//
// Copyright (C) 2019-2024 vdaas.org vald team <vald@vdaas.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package main

import (
	"bytes"
	"context"
	"io/fs"
	"os"
	"os/signal"
	"regexp"
	"slices"
	"syscall"
	"text/template"
	"time"

	"github.com/vdaas/vald/internal/errors"
	"github.com/vdaas/vald/internal/file"
	"github.com/vdaas/vald/internal/log"
	"github.com/vdaas/vald/internal/safety"
	"github.com/vdaas/vald/internal/strings"
	"github.com/vdaas/vald/internal/sync/errgroup"
)

const tmpl = `# syntax = docker/dockerfile:latest
#
# Copyright (C) 2019-{{.Year}} {{.Maintainer}}
#
# Licensed under the Apache License, Version 2.0 (the "License");
# You may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# DO_NOT_EDIT this Dockerfile is generated by hack/docker/gen/main.go

ARG UPX_OPTIONS=-9

{{- range $key, $value := .Arguments }}
ARG {{$key}}={{$value}}
{{- end}}
{{- range $image := .ExtraImages }}
# skipcq: DOK-DL3026
FROM {{$image}}
{{- end}}
# skipcq: DOK-DL3026
FROM {{.BuilderImage}}:{{.BuilderTag}}{{- if not .DevContainer}} AS builder {{- end}}
ARG MAINTAINER="{{.Maintainer}}"
LABEL maintainer="${MAINTAINER}"

ARG TARGETARCH
ARG TARGETOS
ARG GO_VERSION
ARG RUST_VERSION

{{- range $keyValue := .EnvironmentsSlice }}
ENV {{$keyValue}}
{{- end}}

SHELL ["/bin/bash", "-o", "pipefail", "-c"]
# skipcq: DOK-DL3008
RUN apt-get clean \
    && rm -rf \
        /var/lib/apt/lists/* \
        /var/cache/* \
    && apt-get update -y \
    && apt-get upgrade -y \
    && apt-get install -y --no-install-recommends --fix-missing \
    build-essential \
    ca-certificates \
    curl \
    git \
{{- range $epkg := .ExtraPackages }}
    {{$epkg}} \
{{- end}}
    && ldconfig \
    && apt-get clean \
    && rm -rf \
        /var/lib/apt/lists/* \
        /var/cache/* \
    && apt-get autoremove

WORKDIR {{.RootDir}}/${ORG}/${REPO}
COPY Makefile .
COPY .git .
{{- if not .DevContainer}}
{{- if eq .ContainerType 0 }}
COPY go.mod .
COPY go.sum .
{{- else if eq .ContainerType 3 }}
COPY go.mod .
COPY go.sum .
{{- end}}
{{- if .ConfigExists }}
COPY cmd/${PKG}/sample.yaml {{$.TmpConfigPath}}
{{- end}}

{{- range $files := .CopyDirectories }}
WORKDIR {{$.RootDir}}/${ORG}/${REPO}/{{$files}}
COPY {{$files}} .
{{- end}}
{{- range $files := .ExtraCopies }}
COPY {{$files}}
{{- end}}

{{- else}}
WORKDIR {{.RootDir}}/${ORG}/${REPO}
COPY . .
{{- end}}

WORKDIR {{.RootDir}}/${ORG}/${REPO}
{{- if .RunCommands}}
#skipcq: DOK-W1001, DOK-SC2086
RUN {{RunCommands .RunCommands}}
{{- end}}

{{- if not .DevContainer}}
# skipcq: DOK-DL3026
FROM {{.RuntimeImage}}:{{.RuntimeTag}}
ARG MAINTAINER="{{.Maintainer}}"
LABEL maintainer="${MAINTAINER}"

ENV APP_NAME={{.AppName}}

COPY --from=builder {{.BinDir}}/${APP_NAME} {{.BinDir}}/${APP_NAME}
{{- if .ConfigExists }}
COPY --from=builder {{$.TmpConfigPath}} /etc/server/config.yaml
{{- end}}
{{- range $from, $file := .StageFiles }}
COPY --from=builder {{$file}} {{$file}}
{{- end}}
USER nonroot:nonroot

{{- if .Entrypoints}}
ENTRYPOINT [{{Entrypoint .Entrypoints}}]
{{- else}}
ENTRYPOINT ["{{.BinDir}}/{{.AppName}}"]
{{- end}}
{{- end}}`

var docker = template.Must(template.New("Dockerfile").Funcs(template.FuncMap{
	"RunCommands": func(commands []string) string {
		if len(commands) == 0 {
			return ""
		}
		var b strings.Builder
		for i, cmd := range commands {
			if i > 0 {
				b.WriteString(" \\\n    && ")
			}
			b.WriteString(cmd)
		}
		return b.String()
	},
	"Entrypoint": func(entries []string) string {
		if len(entries) == 0 {
			return "\"{{.BinDir}}/{{.AppName}}\""
		}
		return "\"" + strings.Join(entries, "\", \"") + "\""
	},
}).Parse(tmpl))

type Data struct {
	ConfigExists      bool
	DevContainer      bool
	Year              int
	ContainerType     ContainerType
	AppName           string
	BinDir            string
	BuilderImage      string
	BuilderTag        string
	Maintainer        string
	PackageDir        string
	RootDir           string
	RuntimeImage      string
	RuntimeTag        string
	TmpConfigPath     string
	Arguments         map[string]string
	Environments      map[string]string
	Entrypoints       []string
	EnvironmentsSlice []string
	CopyDirectories   []string
	ExtraCopies       []string
	ExtraImages       []string
	ExtraPackages     []string
	Preprocess        []string
	RunCommands       []string
	StageFiles        []string
}

type ContainerType int

const (
	organization          = "vdaas"
	repository            = "vald"
	minimumArgumentLength = 2
	defaultMaintainer     = organization + ".org " + repository + " team <" + repository + "@" + organization + ".org>"
	maintainerKey         = "MAINTAINER"
	defaultRuntimeImage   = "gcr.io/distroless/static"
	defaultRuntimeTag     = "nonroot"
	defaultBuilderImage   = "ghcr.io/vdaas/vald/vald-buildbase"
	defaultBuilderTag     = "nightly"
	defaultBinaryDir      = "/usr/bin"
	defaultTmpConfigPath  = "/tmp/config.yaml"

	goWorkdir   = "${GOPATH}/src/github.com"
	rustWorkdir = "${HOME}/rust/src/github.com"

	agentInernalPackage = "pkg/agent/internal"

	ngtPreprocess   = "make ngt/install"
	faissPreprocess = "make faiss/install"

	helmOperatorRootdir   = "/opt/helm"
	helmOperatorWatchFile = helmOperatorRootdir + "/watches.yaml"
	helmOperatorChartsDir = helmOperatorRootdir + "/charts"
)

const (
	Go ContainerType = iota
	Rust
	DevContainer
	HelmOperator
	Other
)

var (
	defaultEnvironments = map[string]string{
		"DEBIAN_FRONTEND": "noninteractive",
		"HOME":            "/root",
		"INITRD":          "No",
		"LANG":            "en_US.UTF-8",
		"ORG":             organization,
		"PATH":            "${PATH}:/usr/local/bin",
		"REPO":            repository,
	}
	goDefaultEnvironments = map[string]string{
		"GOROOT":      "/opt/go",
		"GOPATH":      "/go",
		"GO111MODULE": "on",
		"PATH":        "${PATH}:${GOROOT}/bin:${GOPATH}/bin:/usr/local/bin",
	}
	rustDefaultEnvironments = map[string]string{
		"RUST_HOME":   "/usr/loacl/lib/rust",
		"RUSTUP_HOME": "${RUST_HOME}/rustup",
		"CARGO_HOME":  "${RUST_HOME}/cargo",
		"PATH":        "${PATH}:${RUSTUP_HOME}/bin:${CARGO_HOME}/bin:/usr/local/bin",
	}

	defaultCopyDirectories = []string{
		"Makefile.d",
		"versions",
	}
	goDefaultCopyDirectories = []string{
		"internal",
		"apis/grpc",
		"pkg/${PKG}",
		"cmd/${PKG}",
	}
	rustDefaultCopyDirectories = []string{
		"rust",
	}

	goInstallCommands = []string{
		`--mount=type=cache,target="${GOPATH}/pkg",id="go-build-${TARGETARCH}" \
    --mount=type=cache,target="${HOME}/.cache/go-build",id="go-build-${TARGETARCH}" \
    make GO_VERSION="${GO_VERSION}" go/install`,
		"make go/download",
	}
	rustInstallCommands = []string{
		"make RUST_VERSION=\"${RUST_VERSION}\" rust/install",
	}
	goBuildCommands = []string{
		"make GOARCH=\"${TARGETARCH}\" GOOS=\"${TARGETOS}\" REPO=\"${ORG}\" NAME=\"${REPO}\" cmd/${PKG}/${APP_NAME}",
		"mv \"cmd/${PKG}/${APP_NAME}\" \"{{$.BinDir}}/${APP_NAME}\"",
	}
	rustBuildCommands = []string{
		"make rust/target/release/${APP_NAME}",
		"mv \"rust/target/release/${APP_NAME}\" \"{{$.BinDir}}/${APP_NAME}\"",
		"rm -rf rust/target",
	}

	clangBuildDeps = []string{
		"cmake",
		"g++",
		"gcc",
		"unzip",
	}
	ngtBuildDeps = []string{
		"liblapack-dev",
		"libomp-dev",
		"libopenblas-dev",
	}
	faissBuildDeps = []string{
		"gfortran",
	}
	devContainerDeps = []string{
		"curl",
		"gawk",
		"git",
		"gnupg2",
		"graphviz",
		"jq",
		"libhdf5-dev",
		"libaec-dev",
		"nodejs",
		"npm",
		"sed",
		"zip",
	}

	ciContainerPreprocess = []string{
		"make GOARCH=${TARGETARCH} GOOS=${TARGETOS} deps GO_CLEAN_DEPS=false",
		"make GOARCH=${TARGETARCH} GOOS=${TARGETOS} golangci-lint/install",
		"make GOARCH=${TARGETARCH} GOOS=${TARGETOS} gotestfmt/install",
		"make buf/install",
		"make hdf5/install",
		"make helm-docs/install",
		"make helm/install",
		"make k3d/install",
		"make k9s/install",
		"make kind/install",
		"make kubectl/install",
		"make kubelinter/install",
		"make reviewdog/install",
		"make tparse/install",
		"make valdcli/install",
		"make yq/install",
		"make minikube/install",
		"make stern/install",
		"make telepresence/install",
	}

	devContainerPreprocess = []string{
		"echo \"installing golang vscode extension dependencies\"",
		"make delve/install",
		"make gomodifytags/install",
		"make gopls/install",
		"make gotests/install",
		"make impl/install",
		"make staticcheck/install",
	}
)

func appendM[K comparable](maps ...map[K]string) map[K]string {
	if len(maps) == 0 {
		return nil
	}
	result := maps[0]
	for _, m := range maps[1:] {
		for k, v := range m {
			ev, ok := result[k]
			if ok {
				v += ":" + ev
			}
			result[k] = v
		}
	}

	for k, v := range result {
		vs := strings.Split(v, ":")
		slices.Sort(vs)
		v = strings.Join(slices.Compact(vs), ":")
		if strings.Contains(v, "${PATH}:") {
			v = strings.TrimPrefix(strings.ReplaceAll(strings.ReplaceAll(v, "${PATH}", ""), "::", ":")+":${PATH}", ":")
		}
		result[k] = v
	}
	return result
}

var re = regexp.MustCompile(`\$\{?(\w+)\}?`)

func extractVariables(value string) []string {
	matches := re.FindAllStringSubmatch(value, -1)
	vars := make([]string, 0, len(matches))
	for _, match := range matches {
		vars = append(vars, match[1])
	}
	return vars
}

func topologicalSort(envMap map[string]string) []string {
	// Graph structures
	inDegree := make(map[string]int)
	graph := make(map[string][]string)

	// Initialize the graph
	for key, value := range envMap {
		vars := extractVariables(value)
		for _, refKey := range vars {
			if refKey != key {
				graph[refKey] = append(graph[refKey], key)
				inDegree[key]++
			}
		}
	}

	queue := make([]string, 0, len(envMap)-len(graph))
	for key := range envMap {
		if inDegree[key] == 0 {
			queue = append(queue, key)
		}
	}

	slices.Sort(queue)

	// Topological sort
	result := make([]string, 0, len(envMap))
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		if value, exists := envMap[node]; exists {
			result = append(result, node+"="+value)
		}
		for _, neighbor := range graph[node] {
			inDegree[neighbor]--
			if inDegree[neighbor] == 0 {
				queue = append(queue, neighbor)
			}
		}
	}

	return result
}

func main() {
	log.Init()
	if len(os.Args) < minimumArgumentLength {
		// skipcq: RVV-A0003
		log.Fatal(errors.New("invalid argument"))
	}

	ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGINT,
		syscall.SIGQUIT,
		syscall.SIGHUP,
		syscall.SIGALRM,
		syscall.SIGKILL,
		syscall.SIGTERM)
	defer cancel()

	maintainer := os.Getenv(maintainerKey)
	if len(maintainer) == 0 {
		maintainer = defaultMaintainer
	}
	year := time.Now().Year()
	eg, egctx := errgroup.New(ctx)
	for n, d := range map[string]Data{
		"vald-agent-ngt": {
			AppName:         "ngt",
			PackageDir:      "agent/core/ngt",
			CopyDirectories: []string{agentInernalPackage},
			ExtraPackages:   append(clangBuildDeps, ngtBuildDeps...),
			Preprocess:      []string{ngtPreprocess},
		},
		"vald-agent-faiss": {
			AppName:         "faiss",
			PackageDir:      "agent/core/faiss",
			CopyDirectories: []string{agentInernalPackage},
			ExtraPackages: append(clangBuildDeps,
				append(ngtBuildDeps,
					faissBuildDeps...)...),
			Preprocess: []string{faissPreprocess},
		},
		"vald-agent": {
			AppName:       "agent",
			PackageDir:    "agent/core/agent",
			ContainerType: Rust,
			RuntimeImage:  "gcr.io/distroless/cc-debian12",
			ExtraPackages: append(clangBuildDeps,
				append(ngtBuildDeps,
					faissBuildDeps...)...),
			Preprocess: []string{
				ngtPreprocess,
				faissPreprocess,
			},
		},
		"vald-agent-sidecar": {
			AppName:         "sidecar",
			PackageDir:      "agent/sidecar",
			CopyDirectories: []string{agentInernalPackage},
		},
		"vald-discoverer-k8s": {
			AppName:    "discoverer",
			PackageDir: "discoverer/k8s",
		},
		"vald-gateway-lb": {
			AppName:    "lb",
			PackageDir: "gateway/lb",
		},
		"vald-gateway-filter": {
			AppName:    "filter",
			PackageDir: "gateway/filter",
		},
		"vald-gateway-mirror": {
			AppName:    "mirror",
			PackageDir: "gateway/mirror",
		},
		"vald-manager-index": {
			AppName:    "index",
			PackageDir: "manager/index",
		},
		"vald-index-correction": {
			AppName:    "index-correction",
			PackageDir: "index/job/correction",
		},
		"vald-index-creation": {
			AppName:    "index-creation",
			PackageDir: "index/job/creation",
		},
		"vald-index-save": {
			AppName:    "index-save",
			PackageDir: "index/job/save",
		},
		"vald-readreplica-rotate": {
			AppName:    "readreplica-rotate",
			PackageDir: "index/job/readreplica/rotate",
		},
		"vald-index-operator": {
			AppName:    "index-operator",
			PackageDir: "index/operator",
		},
		"vald-benchmark-job": {
			AppName:       "job",
			PackageDir:    "tools/benchmark/job",
			ExtraPackages: append(clangBuildDeps, "libhdf5-dev", "libaec-dev"),
			Preprocess: []string{
				"make hdf5/install",
			},
		},
		"vald-benchmark-operator": {
			AppName:    "operator",
			PackageDir: "tools/benchmark/operator",
		},
		"vald-helm-operator": {
			AppName:       "helm-operator",
			PackageDir:    "operator/helm",
			ContainerType: HelmOperator,
			Arguments: map[string]string{
				"OPERATOR_SDK_VERSION": "latest",
			},
			CopyDirectories: []string{
				"internal",
				"charts",
				"hack",
			},
			ExtraCopies: []string{
				"--from=operator /usr/local/bin/${APP_NAME} {{$.BinDir}}/${APP_NAME}",
			},
			ExtraImages: []string{
				"quay.io/operator-framework/helm-operator:${OPERATOR_SDK_VERSION} AS operator",
			},
			ExtraPackages: []string{"upx"},
			Preprocess: []string{
				"mkdir -p " + helmOperatorChartsDir,
				`{ \
        echo "---"; \
        echo "- version: v1"; \
        echo "  group: vald.vdaas.org"; \
        echo "  kind: ValdRelease"; \
        echo "  chart: ` + helmOperatorChartsDir + `/vald"; \
        echo "- version: v1"; \
        echo "  group: vald.vdaas.org"; \
        echo "  kind: ValdHelmOperatorRelease"; \
        echo "  chart: ` + helmOperatorChartsDir + `/vald-helm-operator"; \
    } > ` + helmOperatorWatchFile,
				"make GOARCH=${TARGETARCH} GOOS=${TARGETOS} helm/schema/vald",
				"make GOARCH=${TARGETARCH} GOOS=${TARGETOS} helm/schema/vald-helm-operator",
				"cp -r charts/* " + helmOperatorChartsDir + "/",
				"upx \"{{$.BinDir}}/${APP_NAME}\"",
			},
			StageFiles: []string{
				helmOperatorWatchFile,
				helmOperatorChartsDir + "/vald",
				helmOperatorChartsDir + "/vald-helm-operator",
			},
			Entrypoints: []string{"{{$.BinDir}}/{{.AppName}}", "run", "--watches-file=" + helmOperatorWatchFile},
		},
		"vald-cli-loadtest": {
			AppName:       "loadtest",
			PackageDir:    "tools/cli/loadtest",
			ExtraPackages: append(clangBuildDeps, "libhdf5-dev", "libaec-dev"),
			CopyDirectories: []string{
				"hack/benchmark/assets/x1b",
			},
			Preprocess: []string{
				"make hdf5/install",
			},
		},
		"vald-ci-container": {
			AppName:       "ci-container",
			DevContainer:  true,
			ContainerType: DevContainer,
			PackageDir:    "ci/base",
			ExtraPackages: append(clangBuildDeps,
				append(ngtBuildDeps,
					append(faissBuildDeps,
						devContainerDeps...)...)...),
			Preprocess: append([]string{
				"sysctl -w net.ipv6.conf.all.disable_ipv6=1",
				"sysctl -w net.ipv6.conf.default.disable_ipv6=1",
				"sysctl -w net.ipv6.conf.lo.disable_ipv6=1",
				"sysctl -p",
			}, append(ciContainerPreprocess, ngtPreprocess, faissPreprocess)...),
		},
		"vald-dev-container": {
			AppName:       "dev-container",
			BuilderImage:  "mcr.microsoft.com/vscode/devcontainers/base",
			BuilderTag:    "debian",
			DevContainer:  true,
			ContainerType: DevContainer,
			PackageDir:    "dev",
			ExtraPackages: append(clangBuildDeps,
				append(ngtBuildDeps,
					append(faissBuildDeps,
						devContainerDeps...)...)...),
			Preprocess: append(ciContainerPreprocess,
				append(devContainerPreprocess,
					ngtPreprocess,
					faissPreprocess)...),
		},
	} {
		name := n
		data := d

		eg.Go(safety.RecoverFunc(func() error {
			data.Maintainer = maintainer
			data.Year = year
			if data.BinDir == "" {
				data.BinDir = defaultBinaryDir
			}
			if data.TmpConfigPath == "" {
				data.TmpConfigPath = defaultTmpConfigPath
			}
			if data.RuntimeImage == "" {
				data.RuntimeImage = defaultRuntimeImage
			}
			if data.RuntimeTag == "" {
				data.RuntimeTag = defaultRuntimeTag
			}
			if data.BuilderImage == "" {
				data.BuilderImage = defaultBuilderImage
			}
			if data.BuilderTag == "" {
				data.BuilderTag = defaultBuilderTag
			}

			if data.CopyDirectories != nil {
				data.CopyDirectories = append(defaultCopyDirectories, data.CopyDirectories...)
			} else {
				data.CopyDirectories = make([]string, len(defaultCopyDirectories))
				copy(data.CopyDirectories, defaultCopyDirectories)
			}
			if data.Environments != nil {
				data.Environments = appendM(data.Environments, defaultEnvironments)
			} else {
				data.Environments = make(map[string]string, len(defaultEnvironments))
				data.Environments = appendM(data.Environments, defaultEnvironments)
			}
			switch data.ContainerType {
			case Go:
				data.CopyDirectories = append(data.CopyDirectories, goDefaultCopyDirectories...)
				data.Environments = appendM(data.Environments, goDefaultEnvironments)
				data.RootDir = goWorkdir
				commands := make([]string, 0, len(goInstallCommands)+len(data.Preprocess)+len(goBuildCommands))
				commands = append(commands, goInstallCommands...)
				if data.Preprocess != nil {
					commands = append(commands, data.Preprocess...)
				}
				if file.Exists(file.Join(os.Args[1], "cmd", data.PackageDir)) {
					commands = append(commands, goBuildCommands...)
				}
				data.RunCommands = commands
			case Rust:
				data.CopyDirectories = append(data.CopyDirectories, rustDefaultCopyDirectories...)
				data.Environments = appendM(data.Environments, rustDefaultEnvironments)
				data.RootDir = rustWorkdir
				commands := make([]string, 0, len(rustInstallCommands)+len(data.Preprocess)+len(rustBuildCommands))
				commands = append(commands, rustInstallCommands...)
				if data.Preprocess != nil {
					commands = append(commands, data.Preprocess...)
				}
				data.RunCommands = append(commands, rustBuildCommands...)
			case DevContainer:
				data.CopyDirectories = append(data.CopyDirectories, append(goDefaultCopyDirectories, rustDefaultCopyDirectories...)...)
				data.Environments = appendM(data.Environments, goDefaultEnvironments, rustDefaultEnvironments)
				data.RootDir = goWorkdir
				commands := make([]string, 0, len(goInstallCommands)+len(rustInstallCommands)+len(data.Preprocess))
				commands = append(commands, append(goInstallCommands, rustInstallCommands...)...)
				if data.Preprocess != nil {
					commands = append(commands, data.Preprocess...)
				}
				commands = append(commands, "rm -rf {{.RootDir}}/${ORG}/${REPO}/*")
				data.RunCommands = commands
			case HelmOperator:
				data.Environments = appendM(data.Environments, goDefaultEnvironments)
				data.RootDir = goWorkdir
				commands := make([]string, 0, len(goInstallCommands)+len(data.Preprocess))
				commands = append(commands, goInstallCommands...)
				if data.Preprocess != nil {
					commands = append(commands, data.Preprocess...)
				}
				data.RunCommands = commands
			default:
				data.RootDir = "${HOME}"
				data.Environments["ROOTDIR"] = os.Args[1]
			}

			data.Environments["APP_NAME"] = data.AppName
			data.Environments["PKG"] = data.PackageDir
			data.EnvironmentsSlice = topologicalSort(data.Environments)
			data.ConfigExists = file.Exists(file.Join(os.Args[1], "cmd", data.PackageDir, "sample.yaml"))

			buf := bytes.NewBuffer(make([]byte, 0, len(tmpl)))
			log.Infof("generating %s's docker file", name)
			docker.Execute(buf, data)
			tpl := buf.String()
			buf.Reset()
			template.Must(template.New("Dockerfile").Parse(tpl)).Execute(buf, data)
			file.OverWriteFile(egctx, file.Join(os.Args[1], "dockers", data.PackageDir, "Dockerfile"), buf, fs.ModePerm)
			return nil
		}))
	}
	eg.Wait()
}
